Revision: 838f3de3da6be1ccf2d08b4224938eb0bf1a4c07
Patch-set: 1
File: liblog/logd_write.c

204
Thu Apr 24 22:04:41 2014 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c5e8dfcd_3643e8cf
Bytes: 47
'ret' is a confusing name here. 'total_length'?

204
Thu Apr 24 22:35:22 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c5e8dfcd_3643e8cf
UUID: c5c1bf53_77348a01
Bytes: 206
ret is already defined and used and is a ssize_t, this is merely a result of good 'C' hygiene by not proliferating too many automatic variables. payload_length is more descriptive, it is not a total_length.

204
Thu Apr 24 23:05:57 2014 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c5c1bf53_77348a01
UUID: a5e5abf4_751008b2
Bytes: 78
you know you're allowed to switch to C++? or just add -std=c99 to your CFLAGS?

204
Thu Apr 24 23:12:43 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a5e5abf4_751008b2
UUID: c5c1bf53_57cb0e85
Bytes: 223
This may prejudice me, but I define 'C' as to what the kernel source enforces on us. I can speak some Ukrainian, and English, for example, I feel evil when I mix the two. Purity on one side or the other just feels right :-)

206:1-206:64
Thu Apr 24 23:18:15 2014 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c5e8dfcd_714d7af8
Bytes: 208
Do we care if ret overflows? The check on 209 could be skipped.

(assuming the implementation-specific undefined behavior of signed overflow will lead to something reasonable like wrapping around to negative)

206:1-206:64
Fri Apr 25 15:37:41 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c5e8dfcd_714d7af8
UUID: 2581bb17_364866e9
Bytes: 285
ret will never(tm) overflow as it is a ssize_t ;->. 209 is the code that truncates the buffer, but your point does mean:

if ((size_t)ret > LOGGER_ENTRY_MAX_PAYLOAD)

Should have been used. This code has been refactored and committed, will consider hardening CL based on this critique.

206:1-206:64
Mon Apr 28 19:03:15 2014 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2581bb17_364866e9
UUID: e55a43dc_ebab0561
Bytes: 758
I'm not sure I understand the explanation here, could you elaborate please?

My original, and possibly flawed, interpretation of this was as follows:

if newVec[i].iov_len is equal to SIZE_MAX, then adding it to ret would cause ret to overflow (even if it was a size_t; and certainly since it's a ssize_t, which has a smaller max value). 

On that very academic train of thought, signed integer overflows in C lead to undefined behavior, so simply checking if it went negative is not standards-compliant.

------------

That being said looking at the code paths this seems highly unlikely in practice since a variadic iov_len is always set as the strlen of iov_base; it would be quite hard to allocate 64-bits worth of usable memory by the time it gets here.

210
Thu Apr 24 22:04:41 2014 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a5e5abf4_0ab88360
Bytes: 217
wouldn't this be clearer in the loop? i think you're trying to say "if the last iov_len >= max, -EINVAL; otherwise truncate"?

that seems weird. why not just pass min(total_length, LOGGER_ENTRY_MAX_PAYLOAD) to writev?

210
Thu Apr 24 22:35:22 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a5e5abf4_0ab88360
UUID: 659e536e_14f51a68
Bytes: 433
if the last iov_len < what we can subtract to result in truncation, we KISS return -EINVAL. Doing it in the loop would deal with truncating the packet better I will agree.

In this KISS implementation, we have to ensure that the total length is limited, if the length comes from other fields other than the last one, we will reject the message as unworkable. min on this one iovec will *not* limit the overall length as per our goal.

210
Thu Apr 24 23:05:57 2014 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 659e536e_14f51a68
UUID: a5e5abf4_75c728d9
Bytes: 96
why isn't the simplest thing to just pass min(total_length, LOGGER_ENTRY_MAX_PAYLOAD) to writev?

File: liblog/tests/liblog_test.cpp

499:27-499:34
Thu Apr 24 22:04:41 2014 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 85b427df_af116975
Bytes: 32
where did this number come from?

499:27-499:34
Thu Apr 24 22:35:22 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 85b427df_af116975
UUID: a5be8bc4_16cefa3f
Bytes: 306
From the associated bug, Igor picked it as associated with a separate bug that posted a message this long and left him confused because nothing showed up in logcat (not even truncated). I like it because it is ridiculously long, longer than what even some folks would set the logd circular buffer sizes to.

499:27-499:34
Thu Apr 24 23:05:57 2014 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a5be8bc4_16cefa3f
UUID: 85b427df_a1fc1d93
Bytes: 55
wouldn't 2 * LOGGER_ENTRY_MAX_PAYLOAD be a better idea?

499:27-499:34
Thu Apr 24 23:18:15 2014 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 85b427df_a1fc1d93
UUID: a5e5abf4_35404069
Bytes: 335
In my tests using numbers slightly larger than LOGGER_ENTRY_MAX_PAYLOAD was perfectly fine (it would truncate down to LOGGER_ENTRY_MAX_PAYLOAD once it hit logcat)

It's possible that this value is related to maximum size of an atomic packet for SOCK_DGRAM instead of LOGGER_ENTRY_MAX_PAYLOAD, but I didn't investigate it that far down.

499:27-499:34
Fri Apr 25 15:37:41 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a5e5abf4_35404069
UUID: 2581bb17_d660ea61
Bytes: 768
I want a buffer that exceeds both LOGGER_ENTRY_MAX_PAYLOAD and any inconceivable max dgram size in the network layer. There are multiple sources of truncation in each vintage of all loggers, and an equally inconsistent set of checks. I also want, should this test be used on the legacy kernel logger, to stress it to the max as well.

This test could be performed independently on any Android release, OEM submissions etc. So tailoring it for our current expected behavior and underlying mechanisms and libraries is how I got into this trouble in the first place ;->

BTW, any value above 64K will meet this condition, 3266519 doubly so <grin>

However, svelte phones could choke? I will look into running this test on a hammerhead svelt to be sure, at my convenience.

