Revision: 0a3a3d488c607d252be178cd6f76d92b3efe4c49
Patch-set: 5
File: adb/console.cpp

92:42-92:68
Thu May 07 01:14:04 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cd24a5a6_2488b021
Bytes: 54
I think this needs - 1 to exclude the NULL terminator.

92:42-92:68
Thu May 07 01:54:34 2015 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd24a5a6_2488b021
UUID: 8d1e2d58_e07620d0
Bytes: 180
Yeah, it does. I apparently should have ended my day an hour or two ago...

(though I just tested this as is, so apparently it doesn't make a difference, but I'll change it anyway)

92:42-92:68
Thu May 07 02:22:35 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d1e2d58_e07620d0
UUID: 2d39c1d0_b7d5103b
Bytes: 260
I checked the emulator code and its 'protocol' treats a NULL just like any other non-newline character. Newline is the terminator that it looks for. But yeah, probably a good idea to not send NULL since telnet/netcat (the other popular emulator clients) don't.

94:56-95:29
Thu May 07 01:14:04 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8d1e2d58_20c9b8a6
Bytes: 269
If the quit command could not be sent, the emulator will not close the socket, so adb emu will hang in the read loop below. My opinion is that if you get any write errors here (or above in the for loop), just adb_close() the socket and don't bother doing the read loop.

94:56-95:29
Thu May 07 01:54:34 2015 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d1e2d58_20c9b8a6
UUID: 4d8435cc_38d9d6f4
Bytes: 141
Ack. I think I had been assuming that there was always going to be _something_ pending since that was the cause of this bug, but perhaps not.

94:56-95:29
Thu May 07 02:22:35 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d8435cc_38d9d6f4
UUID: 0d407d41_3f70d387
Bytes: 324
To clarify my previous comment: If the kill command made it to the emulator and the following quit command didn't, then the read loop is ok, but if some other command made it and the following quit command didn't, then that would probably hang forever. Probably simplest to just don't do the read loop if there was an error.

105:17-105:23
Thu May 07 01:14:04 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cd24a5a6_e423d8a0
Bytes: 178
I couldn't quickly see where this is defined. I'm fine as long as this is bigger than ~32 bytes and not a super huge stack value (anywhere from 4K to 64K seems reasonable to me).

105:17-105:23
Thu May 07 01:54:34 2015 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd24a5a6_e423d8a0
UUID: 4d8435cc_185ad20a
Bytes: 140
It's part of the standard library. Defined as some reasonable size to use for this type of thing (and for us it is somewhere in that range).

105:17-105:23
Thu May 07 02:22:35 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d8435cc_185ad20a
UUID: 0d407d41_1f750f78
Bytes: 30
Ah, ok, found it. Sounds good.

