Revision: 9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312
Patch-set: 2
File: base/Android.mk

26:8-26:15
Thu Oct 22 08:45:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f935c6bb_5808296b
Bytes: 135
Instead of using these *_windows_* variables, I could instead just put the contents of the file under #ifdef _WIN32. I'm open to ideas.

File: base/file.cpp

40:0-41:17
Thu Oct 22 23:08:23 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16d269e7_75ed42ba
Bytes: 584
So on Windows these functions will always do the conversion, right? What I've read seems to indicate that the conversions are fairly expensive, do you think it's important to make this optional or add a check to these two functions to see if the conversion is necessary first? (Or maybe it's always necessary on Windows?)

My instinct is that it's probably fine as-is, I don't think anyone is going to be opening or deleting files in a tight enough loop to make performance matter, just wanted to mention it since I am pretty clueless about what else uses these functions besides adb.

File: base/u8.cpp

28:5-28:15
Thu Oct 22 08:45:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3942fe30_9fa0c3cd
Bytes: 145
These WideToUTF8 and UTF8ToWide functions are based on the widen()/narrow() functions from sysdeps_win32.cpp with some changes, elaborated below.

31:2-31:18
Thu Oct 22 08:45:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19337ad8_d90b3faa
Bytes: 63
The unittest found that the old code wasn't handling this case.

42:4-42:24
Thu Oct 22 08:45:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 194a9a42_ac2b9fb8
Bytes: 115
The unittest found that the old code wasn't returning an error in some invalid char situations. This improves that.

50:4-50:17
Thu Oct 22 08:45:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d953a2fb_d9f427f6
Bytes: 244
The old code was just calling fatal() here, but I didn't think that was appropriate for a general library like libbase. A bool is probably better and that's what Chromium's similar APIs return (though Chromium also has APIs that ignore errors).

56:0-58:64
Thu Oct 22 18:28:07 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 194a9a42_2cd16f56
Bytes: 122
If I'm reading it right, according to http://en.cppreference.com/w/cpp/string/basic_string this is guaranteed as of C++11.

56:0-58:64
Thu Oct 22 22:00:00 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 194a9a42_2cd16f56
UUID: 3675adb9_969c8add
Bytes: 65
Yeah, I think this comment doesn't add anything, so I'll kill it.

62:0-65:3
Thu Oct 22 18:28:07 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9618ebd_91ec4c7b
Bytes: 313
As I understand it this should never happen since WideCharToMultiByte() will return the same value on both calls, but if we're going to check this case anyway, perhaps this should be a fatal() if result > chars_required since that would indicate that we probably just corrupted some memory with a buffer overflow.

62:0-65:3
Thu Oct 22 22:00:00 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9618ebd_91ec4c7b
UUID: 166d09ed_1da977fd
Bytes: 436
My thinking is that in reality the return value doesn't even need to be checked (since flags are already checked, invalid chars are already checked, size is already checked, etc.), but check it anyway for defensive programming (for anything unexpected). I'm By Design not doing CHECK/LOG(FATAL) here since it seems like that should be up to the caller instead of a base library. After all, who knows where they're getting their strings.

62:0-65:3
Thu Oct 22 23:08:23 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 166d09ed_1da977fd
UUID: 16d269e7_f554d237
Bytes: 765
In general I agree returning an error is much better than dying. But the caller here has no way to know that this specific event occurred. There's a world of difference between "the conversion failed" and "the conversion failed and we may have corrupted some of your program's memory".

If result > chars_required the program will hopefully have segfaulted already anyway, so exiting from the library is already a possibility. Adding a fatal() just makes it certain, to reduce randomness and prevent some poor programmer having to try to debug this if somehow it does come up.

As you say, this will almost certainly never happen, so if nobody else cares I'm fine leaving this as-is, but IMO as long as we're defensive programming we might as well go all the way :)

71:5-71:67
Thu Oct 22 08:45:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 59725292_8860a70e
Bytes: 99
The old code was passing -1 to WideCharToMultiByte(), but that just made the code more complicated.

90:58-90:78
Thu Oct 22 08:45:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d953a2fb_f9f9ebec
Bytes: 95
The old code passed 0 here, but the unittest found that this flag is better to identify errors.

File: base/u8_test.cpp

146:4-148:51
Thu Oct 22 08:45:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 194a9a42_ec25a7e2
Bytes: 49
This is a change I made to the Chromium unittest.

187:0-187:22
Thu Oct 22 08:45:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9618ebd_c67a8cea
Bytes: 64
This is another change I made to the original Chromium unittest.

212:4-214:51
Thu Oct 22 08:45:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3942fe30_dfaa4bab
Bytes: 64
This is another change I made to the original Chromium unittest.

