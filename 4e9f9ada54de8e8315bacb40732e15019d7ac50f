Revision: 4e9f9ada54de8e8315bacb40732e15019d7ac50f
Patch-set: 2
File: /COMMIT_MSG

21
Wed Oct 26 21:48:05 2016 +0000
Author: William C Roberts <1013433@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_70e9a8cb
Bytes: 197
That's not true with SELinux and Android is gauranteed to have it on. Only if init executes the service will it end up in the proper SELinux domain, assuming nothing but init is in the init domain.

21
Thu Oct 27 01:03:41 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_70e9a8cb
UUID: 815c8406_780de1e1
Bytes: 210
I think that's splitting hairs -- the process will have the capabilities if you look at /proc/self/status. You won't be able to use them if you don't have them allowed in SELinux policy though, that is correct.

File: init/Android.mk

138:0-138:28
Wed Oct 26 20:52:19 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_b094c091
Bytes: 27
LOCAL_MODULE_TAG := eng   ?

File: init/capabilities.cpp

25:8-25:21
Wed Oct 26 19:26:44 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_b04040a4
Bytes: 464
While you have an assert that the cap list hasn't changed, there is nothing that keeps this cap list in the correct order. While it looks correct to me as-is, I find this to be a fragile way to construct it.

I'm not sure how to do with with a std::map, but building this with a C array could be done like this to force array positions:

#define CAP_MAP_ENTRY(cap) [CAP_ ## cap] = #cap

However, see my comment in lookup_cap(), maybe this will all just go away. :)

25:8-25:21
Wed Oct 26 19:40:56 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_b04040a4
UUID: 81b56446_76836852
Bytes: 349
We don't need the list to be in the correct order: this is a map, so it will map strings to ints, and the ints are set by the define, not by the order of the definition. We can change the order to whatever, and it will still do the same thing:

"CAP_SETPCAP", CAP_SETPCAP which is
"CAP_SETPCAP", 8

whatever the position of that line on the list is.

25:8-25:21
Wed Oct 26 19:59:27 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 81b56446_76836852
UUID: c1d83cb2_70608819
Bytes: 41
Ah-ha! Okay, awesome. Yay smart types. :)

69:30-69:44
Wed Oct 26 19:26:44 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_f03ab82d
Bytes: 204
This assumes all builders will have the kernel headers from v3.16 or later (introduction of CAP_AUDIT_READ). Does libcap's cap_from_name() hard code these or does it depend on the kernel uapi headers too?

69:30-69:44
Wed Oct 26 19:40:56 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_f03ab82d
UUID: 81b56446_b6b95026
Bytes: 353
That is true. At least we'd fail at compile time.

I'm pretty sure kernel-headers for Android is in the 4.x range (I had to fix a bug in Minijail when they were changed) but I can double-check.

libcap auto-generates a list of caps based on the headers: https://kernel.googlesource.com/pub/scm/linux/kernel/git/morgan/libcap/+/master/libcap/_makenames.c

69:30-69:44
Wed Oct 26 19:59:27 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 81b56446_b6b95026
UUID: c1d83cb2_b02a00ad
Bytes: 133
This seems frustratingly fragile, but yeah, I can't think of a better way that doesn't fail at runtime which is MUCH harder to debug.

69:30-69:44
Wed Oct 26 19:59:32 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 81b56446_b6b95026
UUID: c1d83cb2_50362417
Bytes: 51
yeah, we're currently 4.4.11 and only move forward.

69:30-69:44
Wed Oct 26 20:11:55 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_50362417
UUID: c1d83cb2_90225cbd
Bytes: 1237
The build will break when a new kernel adds a new capability, but that's easier to debug than failures at runtime. The horrible thing AppArmor does to pull capabilities at build time is:

CAPABILITIES=$(shell echo "\#include <linux/capability.h>" | cpp -dM | LC_ALL=C sed -n -e '/CAP_EMPTY_SET/d' -e 's/^\#define[ \t]\+CAP_\([A-Z0-9_]\+\)[ \t]\+\([0-9xa-f]\+\)\(.*\)$$/CAP_\1/p' | sort)

cap_names.h: /usr/include/linux/capability.h
        echo "$(CAPABILITIES)" | LC_ALL=C sed -n -e "s/[ \\t]\\?CAP_\\([A-Z0-9_]\\+\\)/\{\"\\L\\1\", \\UCAP_\\1\},\\n/pg" > $@

Which produces cap_names.h containing:

{"audit_control", CAP_AUDIT_CONTROL},
{"audit_write", CAP_AUDIT_WRITE},
...

Which gets included like this (adding the ability to pre-define capabilities that may not yet exist in the build kernel headers):

static struct keyword_table capability_table[] = {
        /* capabilities */
        #include "cap_names.h"
#ifndef CAP_SYSLOG
        {"syslog", 34},
#endif
        /* terminate */
        {NULL, 0}
};


If we wanted extreme future-proofing, something similar could be done here, and then adjust the assert to CAP_LAST_CAP check is >= not ==, and any time we needed to depend on a new cap existing, we could update the assert.

69:30-69:44
Wed Oct 26 20:23:25 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_90225cbd
UUID: 815c8406_18cea5ba
Bytes: 259
I'm not too worried about the build breaking when the last time a cap was added was in April, 2014. One build breakage every >2 years on average when we update kernel headers doesn't seem terrible. IMHO it doesn't justify having the shell stuff in a Makefile.

98:31-98:43
Wed Oct 26 19:26:44 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_702fe8e8
Bytes: 134
While it boggles the mind how cap_set_flag() could fail as used here, I think this should report which cap was being attempted anyway.

98:31-98:43
Wed Oct 26 19:40:56 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_702fe8e8
UUID: 815c8406_7867a100
Bytes: 222
It can only fail with EINVAL if you pass bad values for e.g. the CAP_SET argument. I'm happy to remove this error case but I wanted to fail close if e.g. we ever update libcap and things change.

I can add the failing cap.

98:31-98:43
Wed Oct 26 19:59:27 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 815c8406_7867a100
UUID: c1d83cb2_902ffcbc
Bytes: 123
Right, yeah, I meant "improving this error message seems silly since it'll never fail", but yeah, let's add the cap anyway.

125
Wed Oct 26 19:26:44 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_304c50e1
Bytes: 172
Why this instead of wrapping cap_from_name() instead? This code also deviates from everything else using cap_from_name(), in that the "cap_" prefix isn't used in the names.

125
Wed Oct 26 19:40:56 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_304c50e1
UUID: 815c8406_98947592
Bytes: 298
But it matches the capability names used in files like: https://cs.corp.google.com/android/device/google/marlin/marlin/android_filesystem_config.h?q=android_filesystem_config+package:%5Eandroid$&l=1

and all other Android devices.

Also, cap_from_name() uses a linear search while the map is log().

125
Wed Oct 26 19:59:27 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 815c8406_98947592
UUID: c1d83cb2_303f30ee
Bytes: 150
Well, the names could be mangled for cap_from_name(), but since it's both less fragile and more efficient than cap_from_name(), I'm fine with this. :)

139:9-139:29
Wed Oct 26 19:26:44 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_f0c8f809
Bytes: 73
Is this to cover the case were SETPCAP is in Permitted but not Effective?

139:9-139:29
Wed Oct 26 19:40:56 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_f0c8f809
UUID: 815c8406_b89939c9
Bytes: 92
Yes, SETPCAP needs to be in Effective for the bounding set dropping operation below to work.

145:15-145:20
Wed Oct 26 19:26:44 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_502c64f2
Bytes: 57
Other failure points report to ERROR, so this should too.

145:15-145:20
Wed Oct 26 19:40:56 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_502c64f2
UUID: 815c8406_d88eed7b
Bytes: 303
The reason to skip here is that drop_bounding_set is already printing an error. Given that we call set_inh_prm_eff_caps() twice, it made sense to print an extra error here to differentiate which call was failing.

Happy to add an error here as well though, but I don't think it can add more information.

145:15-145:20
Wed Oct 26 19:59:27 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 815c8406_d88eed7b
UUID: c1d83cb2_7039a805
Bytes: 11
Ah, gotcha.

161:15-161:20
Wed Oct 26 19:26:44 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_b0a5e058
Bytes: 70
As with the bounding set failure, this should report to ERROR as well.

161:15-161:20
Wed Oct 26 19:40:56 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_b0a5e058
UUID: 815c8406_f893b1a4
Bytes: 132
The inner function is already reporting an error, and it's unclear whether the error reported here would add any useful information.

160:0-163:16
Wed Oct 26 20:52:19 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_10866c62
Bytes: 33
return set_ambient_caps(to_keep);

File: init/service.cpp

268:8-268:9
Wed Oct 26 19:26:44 2016 +0000
Author: Kees Cook <1082649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_70dd28c5
Bytes: 61
Just to double-check: does the FATAL target kill the process?

268:8-268:9
Wed Oct 26 19:40:56 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_70dd28c5
UUID: 815c8406_18894572
Bytes: 57
It does. And this is post-fork so we're not killing init.

File: init/service.h

165
Wed Oct 26 21:48:05 2016 +0000
Author: William C Roberts <1013433@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_13add668
Bytes: 46
Any reason why were fixing this in this patch?

165
Thu Oct 27 01:03:41 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_13add668
UUID: 815c8406_380369bc
Bytes: 28
Because consistency is good?

165
Thu Oct 27 02:19:32 2016 +0000
Author: William C Roberts <1013433@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 815c8406_380369bc
UUID: c1d83cb2_5edab5ce
Bytes: 37
Separate patch for changes unrelated.

File: init/test/test_service.cpp

25
Wed Oct 26 21:48:05 2016 +0000
Author: William C Roberts <1013433@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_13a83660
Bytes: 92
Why not check that the status is what was set, is their someway we could make the test fail.

25
Thu Oct 27 01:03:41 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_13a83660
UUID: 815c8406_d8fb4da1
Bytes: 476
This service doesn't actually test anything. It's just an easy way to have something to run to test things when one is working on init. I'm just gonna split it off to a separate CL.

We could have this service check that the right capabilities have been set, but I was envisioning this code to be used by folks to test all sorts of things -- every time I write new init functionality, I end up writing a simple test service -- this allows me to not have to do that every time.

25
Thu Oct 27 02:19:32 2016 +0000
Author: William C Roberts <1013433@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 815c8406_d8fb4da1
UUID: c1d83cb2_be73f10c
Bytes: 214
Ahh got you, yeah I have had to do this a few times, it gets old. I can't speak as to the general idiom of adding possibly dead test code to the tree since its not coupled into any form of general testing paradigm.

