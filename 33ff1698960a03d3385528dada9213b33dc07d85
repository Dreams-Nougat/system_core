Revision: 33ff1698960a03d3385528dada9213b33dc07d85
Patch-set: 2
File: adb/fdevent.cpp

51:20-51:32
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 64cf5e9f_aa0413db
Bytes: 159
Make this static? I'm guessing you didn't kill the prev/next fields of fdevent because fdevent.h is also used by sysdeps_win32.cpp which still uses the fields?

65:19-65:31
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 244c8613_612bb218
Bytes: 21
overload operator<< ?

67:8-67:17
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4c34e74_0868af2d
Bytes: 146
What is fde.events for if fde.state already contains FDE_READ/WRITE/ERROR? Maybe there is some potential cleanup between fde.state and fde.events?

105:23-105:30
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4ef2afe_1298c837
Bytes: 16
nit: destroying?

119:4-119:9
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4ef2afe_32698cc0
Bytes: 65
error check? that will conveniently check the validity of the fd.

120:18-120:48
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 04c1426c_cfa2bd9c
Bytes: 165
I thought the point of using emplace() was to avoid unnecessary object construction/copying? Then don't you want to use emplace(fde->fd, fde)? Or do I misunderstand?

121:4-121:14
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 84d4522f_4570d461
Bytes: 215
I think that LOG() from logging.h does not contain an 'if', so it will always run dump_fdevent() even if logging is not enabled. logging.h should probably be fixed (adding the if might fix the errno issue as well?).

132:22-132:29
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 24c9e69c_cdcf6d90
Bytes: 28
set fde->fd=-1 just in case?

195:8-195:17
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4ecf63c_45765e61
Bytes: 29
android::base::StringAppendF?

206:4-206:8
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4ecf63c_a5cdaaf3
Bytes: 90
why PLOG instead of LOG? I don't see any syscall that might set errno. Copy & paste error?

207:8-207:11
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 04c1426c_8fc3a572
Bytes: 30
check for error? handle EINTR?

218:12-218:31
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 84d4522f_901aac38
Bytes: 104
so if I didn't request FDE_ERROR, I can still be called back for it? I guess things are better that way.

221:31-222:41
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 04c1426c_6ff85184
Bytes: 100
So this assumes that the caller will do a read? What if it only does a write? Or is that impossible?

232:12-232:34
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 44cedaa4_48990ffa
Bytes: 103
can one be inserted twice onto the list? Is that ok? Is the pending bit preserved ok in that situation?

254:10-254:12
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4c34e74_135464c6
Bytes: 34
GE? I guess really doesn't matter?

302:8-302:19
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4bdd6e7_d1eee430
Bytes: 287
My understanding is that LOG(FATAL) calls abort() and that can make a coredump. I'm not sure if that makes sense for 'expected' runtime error conditions. In practice, I don't think it comes up because this stuff probably never fails (it isn't like adb is perfect with all memory allocs).

