Revision: 30c1e7cb918c18ec92d30d643849132f99dfe7d4
Patch-set: 13
File: /COMMIT_MSG

9:26-9:33
Fri Oct 14 19:11:32 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bc41ae2d_cb48d5b8
Bytes: 204
Any reason to not make this all or nothing? All we're aiming to do here is make it so we don't break NDK code that already compiles. If they want to opt in to new features, they can opt in to all of them.

9:4-9:25
Fri Oct 14 19:11:32 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bc41ae2d_cb6ff520
Bytes: 39
Let's not use a reserved word for this.

File: include/android/log.h

22
Fri Oct 14 19:11:32 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bc41ae2d_6b61a131
Bytes: 23
Why a different define?

22
Fri Oct 14 19:52:53 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc41ae2d_6b61a131
UUID: bc41ae2d_0b5c9dec
Bytes: 167
Because some use ANDROID_NATIVE_API_LEVEL (some stuff in-tree BTW) and some use __ANDROID_API__, where the later is ours I believe, and the other is used sporadically.

22
Fri Oct 14 20:20:11 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc41ae2d_0b5c9dec
UUID: 5c0d132b_d7ad3c6b
Bytes: 241
Where do you see ANDROID_NATIVE_API_LEVEL? I see it only in cmake files in external: https://cs.corp.google.com/search/?q=ANDROID_NATIVE_API_LEVEL&m=100&sq=package:android&type=cs

ANDROID_NATIVE_API_LEVEL means nothing to the NDK right now.

112
Fri Oct 14 19:11:32 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bc41ae2d_4b8865d2
Bytes: 42
The comment should stay with the function.

112
Fri Oct 14 19:52:53 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc41ae2d_4b8865d2
UUID: bc41ae2d_4b186530
Bytes: 8
True ...

125
Fri Oct 14 19:11:32 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bc41ae2d_eb983125
Bytes: 147
This is new ABI. Do you really want to expose this? Would an app ever need this? The only caller in the entire tree is the Zygote forking function.

125
Fri Oct 14 19:52:53 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc41ae2d_eb983125
UUID: bc41ae2d_0b857d44
Bytes: 399
Double underscore functions exposed to the NDK, but not recommended to be called directly; so there is a point to not include this.

However, I kept it here because it represents completeness, a partner's code caller should have the power to close logging after a fork, and before an exec (the FDs are CLOEXEC so it is a weak argument) or before they continue on the process (the stronger argument).

125
Fri Oct 14 20:20:11 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc41ae2d_0b857d44
UUID: 5c0d132b_17e3b4c0
Bytes: 201
If it gets exposed in the NDK it can *never* change. The ABI and the behavior needs to remain consistent forever.

Don't expose anything for completeness. Expose things because they are useful to apps.

176
Fri Oct 14 19:11:32 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bc41ae2d_6b50c128
Bytes: 37
Everything from here down is new ABI.

176
Fri Oct 14 19:52:53 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc41ae2d_6b50c128
UUID: 7c39f6b7_6ca453a2
Bytes: 145
Do you feel a comment is warranted is why you said this, or is this just a delineation of sorts?

I should move CLOSE interface down here too ...

176
Fri Oct 14 20:20:11 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7c39f6b7_6ca453a2
UUID: 5c0d132b_770b1098
Bytes: 313
My point is that anything below this point is something you're committing to maintain the ABI and behavior of forever. Not thinking about what libc APIs to expose is a mistake that was made nearly a decade ago that we're still paying for. If there's anything in here that isn't useful for an app, don't expose it.

219
Fri Oct 14 19:11:32 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bc41ae2d_0b22ddc1
Bytes: 19
This is never true.

219
Fri Oct 14 19:52:53 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc41ae2d_0b22ddc1
UUID: bc128f45_3a90e128
Bytes: 141
False, if the caller does not define __ANDROID_API__ or ANDROID_NATIVE_API_LEVEL. I found that in most builds, this is the cased (undefined).

219
Fri Oct 14 20:20:11 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc128f45_3a90e128
UUID: 5c0d132b_371598b2
Bytes: 308
Whoops. Yes, you're right. That goes to prove my point that ANDROID_NATIVE_API_LEVEL is confusing when we already have __ANDROID_API__ though. __ANDROID_API__ is always defined, ANDROID_NATIVE_API_LEVEL isn't, despite the fact that they have more or less the same name and seem to represent the same concept.

221
Fri Oct 14 19:11:32 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bc41ae2d_8b16cd61
Bytes: 215
As I said before, we shouldn't be gating any of these things based on target API level (especially not a fake target API level, this is only going to further confuse and already confusing topic for NDK development).

221
Fri Oct 14 19:52:53 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc41ae2d_8b16cd61
UUID: 5c0d132b_9789040a
Bytes: 563
We are going to need to talk about this. This might not be the right forum to educate me ...

Are you talking universally, or just for the MACROs?

I do not want to define any interfaces here that will not work if targeted for JB for example, and generally this gives a strong layer of lint checking to their builds.

For the case of the MACROs, we are special and also switch this all on if LOG_TAG defined which is a substantive bypass, the gate on API Version is to make sure we do not fail in external builds that count on the legacy variant of android/log.h.

221
Fri Oct 14 20:20:11 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c0d132b_9789040a
UUID: 5c0d132b_f733a056
Bytes: 424
Yes, just the macros. ABI should be gated by the version that it's available in.

ANDROID_USE_LOG_MACROS (or ANDROID_HIDE_LOG_MACROS, if we prefer on by default, either works for me) would make this a lot more clear. It isn't obvious that LOG_TAG would change the interface provided here. Also remember that the reason this came up in the first place is that some external code was using LOG_TAG to mean something different.

262
Fri Oct 14 19:11:32 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bc41ae2d_0b0bbd39
Bytes: 45
Why are we exposing the radio log to the NDK?

262
Fri Oct 14 19:52:53 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc41ae2d_0b0bbd39
UUID: bc41ae2d_0b0e5df0
Bytes: 122
Because we would like to allow radio components to be able to built out-of-tree. I had the BRCM folks complain about this.

262
Fri Oct 14 20:20:11 2016 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bc41ae2d_0b0e5df0
UUID: 5c0d132b_57ac8c41
Bytes: 131
Is the radio log really the only thing blocking that? Most vendor code depends on a ton of things that aren't available in the NDK.

262
Fri Oct 14 21:23:55 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c0d132b_57ac8c41
UUID: 5c0d132b_f73f207c
Bytes: 363
even if logging isn't the _only_ thing, fixing this would be a step in the right direction.

(the _real_ question is your earlier one about "do you really understand the long-term implications of exposing something in the NDK?". we should definitely make sure we've read salyzyn his rights [and that he's understood them] before we let him incriminate himself...)

