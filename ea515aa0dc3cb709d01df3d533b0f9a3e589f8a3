Revision: ea515aa0dc3cb709d01df3d533b0f9a3e589f8a3
Patch-set: 2
File: adb/adb_auth_host.cpp

309:19-309:20
Fri Aug 28 23:27:31 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 849451c2_582f3c40
Bytes: 137
nit: lowercase to fit with the other adb "error: blah" output ;-) Doesn't really matter; what matters most is real info the user can use.

311:12-311:22
Fri Aug 28 23:27:31 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 046221c0_315b8080
Bytes: 144
kill the line? (I suppose fatal() should be marked with a compiler attribute to specify that it doesn't return, but can't do it all in a day...)

417:24-417:40
Sat Aug 29 00:20:50 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 248c8586_84a6c895
Bytes: 786
It turns out that adbkey.pub does not contain any \r or \n, so *in practice* it doesn't matter whether this reads it in text or binary mode. Adbkey.pub is written by write_public_keyfile which uses fopen which defaults to text mode, but the data that is written out is <base64><space><username>@<hostname> which does not have any \r or \n to translate in the first place.

So in practice RFTS() is fine here.

But taking a step back, how should this really be done? My opinion is that since this file format is really text, it should use text mode on both read and write on Windows. But that's just my opinion and I could be convinced out of it.

Personally on my machines I use editors that handle unix style line-endings, but silly Notepad that comes with the OS doesn't recognize it.

File: adb/commandline.cpp

535:9-535:40
Sat Aug 29 00:20:50 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4700952_67fdfb77
Bytes: 1199
I'm convinced that this reads in text mode and breaks adb sideload. So I think you could either modify RFTS() to pass _O_BINARY to open() always, or maybe create ReadFileToString(arg0, arg1, extra_open_flags) where you pass _O_BINARY (or make it a boolean, whatever), or make another API, etc. you get the idea.

So basically, Windows is annoying because it forces cross-platform code to have this notion of textmode vs. binmode if it wants the files to be readable by Notepad. It's up to you guys how you want to deal with this. You could just say 'screw Notepad' and just use binary mode everywhere. Personally I can live with that, but I don't know about everyone else (here is an example: idea.log only has \n so newbie Windows Android Studio users can't even easily read the log comfortably!)

BTW, loading binary data into std::string sounds ok at the outset (because std::string is documented to handle embedded nulls), but I read that if you accidentally call c_str(), that truncates to the first NULL. That sounds a bit scary. Maybe it means that you really want ReadFileToString (text mode) and ReadFileToVector (binary). I dunno, these are really design questions for component owners. :)

535:9-535:40
Tue Sep 01 18:00:47 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c4700952_67fdfb77
UUID: 8497f201_b268a801
Bytes: 645
i checked the google3 code this is based on, and they use O_BINARY or equivalent. (you can see chromium's copy at https://code.google.com/p/chromium/codesearch#chromium/src/base/files/file_util.cc&sq=package:chromium&l=133.)

the only places adb currently uses these functions are in Linux-only code anyway, so it seems like adding that flag wouldn't break anything.

(on the whole i also think this behavior is less surprising. the obvious exception being cases where the next thing you plan on doing is android::base::Split(content, "\n"), but maybe that's just a sign we should have something like simpleperf's LineReader class in libbase...)

535:9-535:40
Tue Sep 01 19:48:47 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8497f201_b268a801
UUID: e486eed4_dbf78bc0
Bytes: 139
Ok, O_BINARY or equiv sounds fine to me. If this needs to be revisited in the future you can add ReadTextFileToString() or LineReader, etc.

