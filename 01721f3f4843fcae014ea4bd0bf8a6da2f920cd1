Revision: 01721f3f4843fcae014ea4bd0bf8a6da2f920cd1
Patch-set: 4
File: liblog/logd_write.c

38
Fri Feb 13 04:10:58 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eb2f888a_6e00efe5
Bytes: 79
please don't use this in new code. use <stdatomic.h> for C or <atomic> for C++.

38
Fri Feb 13 15:11:55 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb2f888a_6e00efe5
UUID: 2b9440fe_fdf04798
Bytes: 164
_that_ was the comment I was looking for. I had a voice in my head that said 'do not use android atomic', but when I polled the group I was met with shrugs. Thanks!

38
Fri Feb 13 16:47:17 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2b9440fe_fdf04798
UUID: 0b4cdc89_47de301e
Bytes: 906
for next time, we did add a comment to the cutils include file:

/*
 * A handful of basic atomic operations.
 * THESE ARE HERE FOR LEGACY REASONS ONLY.  AVOID.
 *
 * PREFERRED ALTERNATIVES:
 * - Use C++/C/pthread locks/mutexes whenever there is not a
 *   convincing reason to do otherwise.  Note that very clever and
 *   complicated, but correct, lock-free code is often slower than
 *   using locks, especially where nontrivial data structures
 *   are involved.
 * - C11 stdatomic.h.
 * - Where supported, C++11 std::atomic<T> .
 *
 * PLEASE STOP READING HERE UNLESS YOU ARE TRYING TO UNDERSTAND
 * OR UPDATE OLD CODE.

sadly we didn't have the balls to add #warning. even ignoring vendor code, there's a *lot* of code using this and its [also] evil libutils twin: https://cs.corp.google.com/#search/&q=include.*utils/atomic.h%20-file:vendor/%20-file:device/&sq=package:%5Eandroid$&type=cs&m=100&sort=1

38
Fri Feb 13 17:16:13 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0b4cdc89_47de301e
UUID: 6b5d5831_6a9fb7d2
Bytes: 1201
Agreed, sem_wait and sem_post are only a handful of ns when there is no contention; roughly the same as the atomic (C11) operations (as they are, themselves, atomic operations, when there is no contention). Atomics by themselves only make sense for a single counter like we have here.

TL;DR

The 20us sem_post overhead in the producing thread, or when contention occurs, when it has to tell Linux to wakeup the associated thread(s) is _killing_ me. Regardless, futex as used underneath is still the fastest way to deal with inter-thread locking; I just wish there was a way to tell it to wake up the associated thread(s) lazy by instead inside the kernel posting the wakes into a workqueue quickly and hence return to the producing caller quicker. That 20us of overhead is a result of searching immediately for the key, and twiddling the scheduler for the associated thread(s) which takes time in the context of the caller. I just wish there was some magic bullet, especially in situations where wakeup is normal (as compared to occasionally contended). POSIX offers no means to specify a semaphore attribute as lazy or not, and futex offers no means to specify lazy or not; so not today for sure ...

