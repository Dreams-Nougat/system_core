Revision: 2f3bd776adc409820434a38707e42ddabc42139a
Patch-set: 5
File: debuggerd/crash_dump.cpp

49
Wed Oct 26 18:06:06 2016 +0000
Author: Zach Riggle <1059554@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_2defd9d3
Bytes: 88
This can be spoofed via PID recycling.  You must use openat(), open()/fopen() is unsafe.

49
Wed Oct 26 18:15:14 2016 +0000
Author: Josh Gao <1079148@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_2defd9d3
UUID: c1d83cb2_0d9ad557
Bytes: 233
The idea was to fetch all of these values, and then check that the process hasn't died yet via getppid, but I like openat much better. ptrace is still vulnerable to this, so we still need to make sure that the process is still alive.

49
Wed Oct 26 18:45:53 2016 +0000
Author: Zach Riggle <1059554@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_0d9ad557
UUID: c1d83cb2_b00960a0
Bytes: 230
Yeah, it's probably an easier solution to pass around a file descriptor with /proc/XXX open.  I'm not sure how to avoid the race condition with ptrace, except to use openat() to get /proc/XXX and then check /status for "TracerPID"

49
Wed Oct 26 19:02:00 2016 +0000
Author: Josh Gao <1079148@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_b00960a0
UUID: c1d83cb2_f0611852
Bytes: 605
If the process we're trying to dump dies, we'll be reparented onto init (or someone else guaranteed to be an ancestor of us, if PR_SET_CHILD_SUBREAPER is on), so checking if getppid() changes after we PTRACE_ATTACH everything should be sufficient. This is complicated a bit because we need to fork and then ptrace in that child, because we need to be able to waitpid on the child before we exit the signal handler, to avoid leaving a zombie when doing a non-fatal dump, so we'll actually need to parse /proc/getppid()/status or do IPC to call getppid() in the parent or something. (TODOs on line 211, 280)

78
Wed Oct 26 18:06:06 2016 +0000
Author: Zach Riggle <1059554@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_6de9d1cb
Bytes: 88
This can be spoofed via PID recycling.  You must use openat(), open()/fopen() is unsafe.

101
Wed Oct 26 18:06:06 2016 +0000
Author: Zach Riggle <1059554@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_4de68dfd
Bytes: 88
This can be spoofed via PID recycling.  You must use openat(), open()/fopen() is unsafe.

180:13-180:32
Wed Oct 26 03:12:56 2016 +0000
Author: Josh Gao <1079148@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_aa0f2f51
Bytes: 62
FIXME: this is presumably not the correct way of doing things.

