Revision: 53f2bc72b87f5eac0ca91d934d4cb5ebc52fa5f2
Patch-set: 1
File: logd/LogBuffer.cpp

673:12-676:9
Wed Oct 07 21:02:31 2015 +0000
Author: Todd Kjos <1069543@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 30592d74_2fae190a
Bytes: 345
Did you intend to do a "break" within the "retry == 1" block? If not, then this is really the 2nd-to-last pass since we will go back to the top of the loop and execute lines 665-667 again. Seems odd.

Would it be better to change 668+ to:

  if (!busy)
      break;
  if (!--retry) {
    // last pass
    <all the last pass stuff>
    break;
  }

673:12-676:9
Wed Oct 07 22:50:32 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 30592d74_2fae190a
UUID: 504861a0_15d364e4
Bytes: 536
The busy = prune(id, 1, uid)

Does not clear, it merely removes one entry if it needs to. I figured the 1 is very clearly not a ULONG_MAX. Its real purpose it to check if it is still busy after the sleep, if it is still busy, then we want to tell all the readers to 'go away', we kill them, then do yet another run to clear all the entries ULONG_MAX. If it is not busy, then we preserve the readers and let one more run go unhindered.

The one-line comment on line 663 describes what we are doing, it is obviously not enough comment ;-{

673:12-676:9
Wed Oct 07 23:13:31 2015 +0000
Author: Todd Kjos <1069543@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 504861a0_15d364e4
UUID: 504861a0_3504a0e5
Bytes: 354
What isn't clear is why you are doing all the "kill reader" stuff in the 2nd-to-last pass (and the "last pass" comment is misleading since this is the end of the previous.

Just to make it clearer, how about moving this stuff to the top of the loop (before the busy=prune()), so it really is part of the last pass instead of the end of the previous pass.

