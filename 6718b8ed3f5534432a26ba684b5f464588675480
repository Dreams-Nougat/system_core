Revision: 6718b8ed3f5534432a26ba684b5f464588675480
Patch-set: 2
File: include/nativebridge/native_bridge.h

26:43-26:44
Mon Aug 11 18:21:20 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6e5ebf4_67913d43
Bytes: 154
why do some APIs need a const std::string& while others take a const char * ? It's fine if this is the most convenient for callers, but it just seems odd.

26:43-26:44
Mon Aug 11 18:28:09 2014 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6e5ebf4_67913d43
UUID: 76ea93f0_d1ff04ca
Bytes: 261
Is this an API that will be used from other projects? Until stlport is out of the picture entirely, we need to be careful about using STL containers at API boundaries because the two STLs are not ABI compatible (we ran in to this problem while moving ART over).

26:43-26:44
Mon Aug 11 18:31:38 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76ea93f0_d1ff04ca
UUID: f6d0433d_55b88cc6
Bytes: 69
Yeah, that's a good point. We will be using this from other projects.

26:43-26:44
Mon Aug 11 21:31:44 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6d0433d_55b88cc6
UUID: 16d4f72c_590207dc
Bytes: 107
I thought frameworks and Art are moved over. On the Art side it's fine to switch to const char* if must be.

File: nativebridge/native_bridge.cc

52
Mon Aug 11 18:21:20 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6e5ebf4_24a9f3fe
Bytes: 115
"cbs [IN] the pointer to NativeBridgeCallbacks"

art_cbs -> cbs, NativeBridgeArtCallbacks -> NativeBridgeCallbacks.

52
Mon Aug 11 21:31:44 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6e5ebf4_24a9f3fe
UUID: 16d4f72c_990f7f03
Bytes: 100
No. This was Art callbacks that the native bridge can use. I guess the name is now RuntimeCallbacks.

54:46-55:54
Mon Aug 11 18:21:20 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56a3cfb2_a4725aaf
Bytes: 3
cbs

114:51-114:84
Mon Aug 11 15:44:53 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56a3cfb2_f9040b7e
Bytes: 145
I'm not sure what's the best strategy to pass this one. Thoughts?

Passing it together with the nb_library_string seems like a good option to me.

114:51-114:84
Mon Aug 11 16:33:45 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56a3cfb2_f9040b7e
UUID: d6133f9f_19ac578c
Bytes: 18
Makes sense to me.

114:51-114:84
Mon Aug 11 17:39:35 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6133f9f_19ac578c
UUID: 56a3cfb2_c4b75ed7
Bytes: 255
My only issue with this will related to pointer ownership, i.e. it seems easy to lose track of it when passing it through so many layers. I guess it can't be helped. 

Is there any reason why initialize doesn't take a const pointer? or it's just a glitch?

114:51-114:84
Mon Aug 11 21:31:44 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56a3cfb2_c4b75ed7
UUID: 76c53378_9ccc0970
Bytes: 209
I think a const * is fine, and it makes sense to have the caller retain ownership. Libnativebridge should not have to manage this, just pass it on. Then the caller can have this as a global (as it was in Art).

