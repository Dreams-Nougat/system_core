Revision: f3b0e2a7f13efd6fe8432e31617c87c3c51523cf
Patch-set: 2
File: adb/commandline.cpp

448:44-448:75
Tue Nov 03 22:08:36 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6bb729e_0af7fbb7
Bytes: 405
nit: raw ShellProtocol* might be preferable here, doesn't really matter to me I just remembered the C++ primer saying something about this.

(from C++ primer: "In general, if you find yourself wanting to use a pointer or reference to a unique_ptr, you're probably not transferring ownership, so you should usually just pass a pointer or reference to the underlying object, and keep unique_ptr out of it.")

470:4-470:18
Tue Nov 03 22:08:36 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6335e1f_e17c4650
Bytes: 291
Is it safe to do this in a signal handler? I can't seem to find concrete information in the man pages but the articles/forum posts that I can find indicate this is unsafe.

Would it be feasible to drop the lock and instead only enable SIGWINCH handling after the read thread has been set up?

470:4-470:18
Tue Nov 03 22:52:39 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6335e1f_e17c4650
UUID: b65c3e65_5c987159
Bytes: 114
Why not just set a volatile sig_atomic_t flag here and read it when read() returns EINTR? As well as David's idea.

470:4-470:18
Wed Nov 04 00:11:30 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b65c3e65_5c987159
UUID: f6a3167e_26feb823
Bytes: 295
because read won't return EINTR unless i send the SIGUSR1. the SIGWINCH goes to the main thread (strictly, an arbitrary thread not of our choosing) so this signal handler exists merely to ensure that _some_ signal gets sent to the stdin read thread, which will cause the read to fail with EINTR.

470:4-470:18
Wed Nov 04 00:31:02 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6a3167e_26feb823
UUID: 36aa0e54_6821db2f
Bytes: 82
If you do David's suggestion, can you kill the mutex & check of stdin_read_thread?

470:4-470:18
Wed Nov 04 01:08:48 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36aa0e54_6821db2f
UUID: 36aa0e54_0baf0157
Bytes: 329
there's no good way in our current code to implement the "after" part. (this lock is my implementation of the "after" part. it's how we know that the other thread got far enough for us to safely start sending it signals.) i think the real fix is to not have two threads, but that's a big enough change we should do it separately.

470:4-470:18
Wed Nov 04 17:02:51 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36aa0e54_0baf0157
UUID: 16d0aae3_fb9b5be2
Bytes: 407
I may be misunderstanding the problem here, but according to signal(7), signals will be delivered to an arbitrary thread selected from those which do not block the signal.

Can we just block SIGWINCH before spawning the thread, and then use pthread_sigmask() to unblock it only for this thread, guaranteeing that it's delivered to only this thread? Then we can avoid the SIGUSR1 secondary signal altogether.

470:4-470:18
Wed Nov 04 18:45:00 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16d0aae3_fb9b5be2
UUID: b6335e1f_eab6dba4
Bytes: 442
i couldn't get that to work before, but i just gave it another go, and it's working now.

i think i gave up too early last time because i was under the misapprehension that this was running in the _server_ so we'd need to notify multiple threads anyway. when i realized it was in the client and simplified the working code i had, i didn't try hard enough to go back to using SIGWINCH directly.

thanks for encouraging me to backtrack further!

532
Tue Nov 03 19:33:00 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96401a44_8ded56e9
Bytes: 306
as an aside: now we're always building for Windows too, i wonder if we should just get rid of these #defines for Unix? (but keep them for Windows.) that way Unix-only code doesn't need to do stuff like this, but we'll still know straight away if we've tried to use bare 'read' in code that runs on Windows.

532
Tue Nov 03 22:08:36 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96401a44_8ded56e9
UUID: b6335e1f_a126be93
Bytes: 173
Makes sense to me, enabling a 3rd read() function is kind of a bummer but it seems necessary, and better than having to mess with macros for a legitimate use case like this.

532
Tue Nov 03 22:52:39 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6335e1f_a126be93
UUID: 16a98a5f_e783bcb7
Bytes: 278
It's up to you guys. I guess there's two main schools of thought:

- Make read() on Windows work with C Runtime fds and sysdeps fds.
- Split read() into unix_read() which works with C Runtime fds and adb_read() which works with sysdeps fds.

So the proposal is for a 3rd option?

532
Wed Nov 04 00:11:30 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16a98a5f_e783bcb7
UUID: 36c12e1a_50ccd23e
Bytes: 339
a 4th option would be "remove the TEMP_FAILURE_RETRY from unix_read on Unix, and explicitly write TEMP_FAILURE_RETRY in all but one call site". (which is the real problem that brought me here, not so much the fact that we have two different reads.)

i wasn't planning on doing anything about this right now, just throwing out another idea.

532
Wed Nov 04 00:31:02 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36c12e1a_50ccd23e
UUID: f6a3167e_c935751d
Bytes: 89
4th option sounds ok if you generally want to keep the codebase unix-ish (which is fine).

532
Wed Nov 04 01:08:48 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6a3167e_c935751d
UUID: 56c6a231_54d7e4e4
Bytes: 532
there are very few uses of unix_read, and most of them are in non-Windows code. this and copy_to_file are the only exceptions. if we ripped out the STDIN_FILENO support from copy_to_file (and just asserted that we're _not_ dealing with stdin, which we currently never are), we'd really just have this call site, and it really just wants _console_read.

but i don't have a particularly strong opinion. things aren't too bad right now, and mostly work.

i'll copy the #define read ___xxx_read here for now, to preserve the status quo.

682
Tue Nov 03 19:33:00 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96401a44_cdd35e29
Bytes: 104
(i'd like to move all this code out into a separate file, but i've been disruptive enough here already.)

