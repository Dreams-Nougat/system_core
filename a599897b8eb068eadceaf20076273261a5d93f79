Revision: a599897b8eb068eadceaf20076273261a5d93f79
Patch-set: 1
File: /COMMIT_MSG

16
Fri Dec 16 00:19:26 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dabe6b36_98e601ce
Bytes: 82
doesn't this mean we're doing that on every exec? should we be caching the result?

16
Fri Dec 16 00:41:37 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dabe6b36_98e601ce
UUID: 1af2c318_a3491eae
Bytes: 154
Yes, and that's a fair point. As I mentioned in a comment to Nick, who do we feel about a LazyInstance kind of thing that caches the result on first call?

16
Fri Dec 16 00:55:37 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1af2c318_a3491eae
UUID: dabe6b36_cc8f1e10
Bytes: 5
sgtm.

File: init/capabilities.cpp

72
Fri Dec 16 00:04:47 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dabe6b36_7d633723
Bytes: 58
Missing static.

"static unsigned int GetLastValidCap() {"

72
Fri Dec 16 00:40:39 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dabe6b36_7d633723
UUID: 1af2c318_039452ce
Bytes: 46
No need, these live in an anonymous namespace.

72
Fri Dec 16 00:53:03 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1af2c318_039452ce
UUID: dabe6b36_ec777a3d
Bytes: 94
can we use static instead? most of our code does, and i made the same mistake looking at this.

73:13-73:16
Fri Dec 16 00:04:47 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dabe6b36_4637940b
Bytes: 173
to match the signature of prctl(), should be unsigned long. "man prctl". (although the bionic declaration is "int prctl(int option, ...);", so I'm not 100% sure on this one)

73:34-73:35
Fri Dec 16 00:10:26 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dabe6b36_dd76ab7a
Bytes: 133
The minimum kernel we support is 3.8, so you could reduce a few system calls by starting this at CAP_WAKE_ALARM (Linux 3.0 timeframe)

73:34-73:35
Fri Dec 16 00:42:11 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dabe6b36_dd76ab7a
UUID: 1af2c318_e3532656
Bytes: 63
I feel like if we only do it once, we can probably be thorough.

73:34-73:35
Fri Dec 16 00:50:29 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1af2c318_e3532656
UUID: dabe6b36_5835a991
Bytes: 264
I guess if you want to support kernels without, for instance, CAP_SETUID, then sure.  :-) Anything before CAP_NET_RAW (cap #13) has been around since before the dawn of time. I'm not sure what additional confidence this gives you, but it does have a non-zero cost.

83
Fri Dec 16 00:04:47 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dabe6b36_5dbc7b67
Bytes: 49
Missing static

"static bool DropBoundingSet ..."

83
Fri Dec 16 00:40:39 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dabe6b36_5dbc7b67
UUID: 1af2c318_e3984606
Bytes: 47
No need, this is inside an anonymous namespace.

97
Fri Dec 16 00:04:47 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dabe6b36_9d7713f1
Bytes: 45
Missing static

"static bool SetProcCaps ..."

97
Fri Dec 16 00:40:39 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dabe6b36_9d7713f1
UUID: 1af2c318_438e5ac2
Bytes: 33
Same, inside anonymous namespace.

131
Fri Dec 16 00:04:47 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dabe6b36_5d6e3b1b
Bytes: 47
missing static

"static bool SetAmbientCaps..."

131
Fri Dec 16 00:40:39 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dabe6b36_5d6e3b1b
UUID: 1af2c318_238b4eb2
Bytes: 7
Same =)

155:0-164:5
Fri Dec 16 00:04:47 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dabe6b36_fd9d67a5
Bytes: 600
this feels like an awkward place for this. Before the invocation of every service which uses capabilities, you call GetLastValidCap. This recomputes the exact same value over and over again. This is going to have overhead on every service invocation.

Instead, it feels like this would be better placed in service.cpp function ParseCapabilities, so the check only occurs on service parsing, not service execution. That way, even if the service isn't executed or is disabled, an error message will still be generated.

Extra points for caching this value to avoid recomputing this over and over again.

155:0-164:5
Fri Dec 16 00:40:39 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dabe6b36_fd9d67a5
UUID: 1af2c318_63855698
Bytes: 482
That's a fair point. The only reason to put it here was to hide the implementation details of the number of caps from the users of this file -- arguably, you might not want to force every caller of this interface to have to find the runtime value of cap_last_cap. If you still think losing that encapsulation in the name of performance is worth it, I'm happy to move things around.

Alternatively, we could just cache things in this file, with a lazy initializer. What do you think?

155:0-164:5
Fri Dec 16 00:50:29 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1af2c318_63855698
UUID: dabe6b36_98e0c1e4
Bytes: 310
If you keep it here, you'd still miss the error message if the service doesn't execute. For instance, if it's a disabled service. Moving it to the service parsing would emit an error even if the service itself is never triggered.

Lazy initializer SGTM. I think it's thread safe too, but enh would know better.

155:0-164:5
Fri Dec 16 00:55:37 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dabe6b36_98e0c1e4
UUID: dabe6b36_ccba7ea3
Bytes: 196
yeah, the usual

  static unsigned GetLastValidCap() {
    static unsigned result = ComputeLastValidCap();
    return result;
  }

idiom is thread-safe. the compiler inserts the necessary locking.

