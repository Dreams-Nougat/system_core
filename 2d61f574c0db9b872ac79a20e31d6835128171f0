Revision: 2d61f574c0db9b872ac79a20e31d6835128171f0
Patch-set: 1
File: adb/file_sync_service.cpp

131:12-131:24
Tue Aug 25 03:06:29 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 048f817d_47ca49b4
Bytes: 300
I went into the git history and figured out what is really going on: the old fail_errno and fail_message used to return 0 on success and -1 on error, but when the return value type was changed from int to bool, all the callsites were not inverted. So I think we've been misinterpreting all the calls.

144:33-144:34
Tue Aug 25 02:46:45 2015 +0000
Author: Christopher Ferris <1019050@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c42ba915_682cde98
Bytes: 118
Any chance in a follow-up cl you could change all of the instances of the variable s to actually be a meaningful name?

144:33-144:34
Tue Aug 25 03:25:32 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c42ba915_682cde98
UUID: 4485f957_537f6f1b
Bytes: 237
yeah, SyncConnection helps fix this problem. it's just not plumbed through everywhere yet. i think the problem is that these functions have too many fds. (in the short term, think "s == socket" --- it's the fd for talking to the client.)

153:12-153:22
Tue Aug 25 03:06:29 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4750d3f_bf977551
Bytes: 225
I think the old code used to only bail if there was an error sending the errmsg to the client. If the errmsg was sent ok, it would set fd=-1, then continue (and ignore the secure_mkdirs failure). What do we really want to do?

153:12-153:22
Tue Aug 25 03:31:56 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4750d3f_bf977551
UUID: a42a3512_26037887
Bytes: 258
agreed, but i don't see how that made any sense. if something's gone wrong, i think we should stop digging. does anyone have a counterexample?

(note also that the other end -- the client -- will stop as soon as it sees one of these ID_FAIL messages anyway.)

153:12-153:22
Tue Aug 25 03:37:22 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a42a3512_26037887
UUID: a4fcf5c5_aaaf6b99
Bytes: 444
Maybe the old code was just written with hopes of some advanced client or a 'streaming' client that sends a lot of commands in batch and reads the responses in batch (and hence doesn't want to fail on an early command). That almost makes sense given the 'start stat / finish stat' code in file_sync_client.cpp that you were going over the other day. Anyway, the real answer is probably before my time. I'm fine with the improved error checking.

153:12-153:22
Tue Aug 25 03:47:17 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4fcf5c5_aaaf6b99
UUID: e4750d3f_3ffdc578
Bytes: 128
yeah, that would make sense. luckily the ID_STAT command always returns success. though that's kind of a bug in its own right...

161:8-162:18
Tue Aug 25 03:06:29 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 84253145_215cc5f7
Bytes: 240
I think the old code would only bail if there was an err sending errmsg. If that succeeded, it would set fd=-1, go down into the loop below and read whatever the client sent (but don't write the data anywhere). What do we really want to do?

165:12-166:22
Tue Aug 25 03:06:29 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4750d3f_5fa451ba
Bytes: 108
The old code would report the err, but then continue on, ignoring the failure. What do we really want to do?

195:8-195:19
Tue Aug 25 03:06:29 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4700952_2fca78b3
Bytes: 185
This code looks crazy, but it was because the old code could end up with fd < 0, in which case it would still want to read all the data from the socket and not write it anywhere. Crazy?

199:12-199:22
Tue Aug 25 03:06:29 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4750d3f_7fa10da9
Bytes: 151
The old code would send the errmsg, bail if that failed, but if it succeeded, continue reading the socket and throw away what is read. What do we want?

203:2-203:18
Tue Aug 25 02:46:45 2015 +0000
Author: Christopher Ferris <1019050@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4485f957_d3727f58
Bytes: 108
I don't think you need this check any more. You can't get here if fd < 0, you would skip to fail from above.

203:2-203:18
Tue Aug 25 03:25:32 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4485f957_d3727f58
UUID: 248c8586_96785a37
Bytes: 4
Done

206:8-206:44
Tue Aug 25 02:46:45 2015 +0000
Author: Christopher Ferris <1019050@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 84253145_61695d98
Bytes: 48
Do you need to do this in any of the fail cases?

206:8-206:44
Tue Aug 25 03:25:32 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 84253145_61695d98
UUID: 84253145_e1e7ada0
Bytes: 103
good question. [+nnk]: is there a reason why we can't just call this as soon as we've created the file?

206:8-206:44
Tue Aug 25 18:05:33 2015 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 84253145_e1e7ada0
UUID: e4750d3f_c532aef6
Bytes: 276
Yes, you could call it when you create the file. The current solution was easier to implement. The net result should be the same.

The only concern I have is regarding symlinks. I'm not sure of the behavior of that function when path is a symlink.

Either way is fine with me.

206:8-206:44
Tue Aug 25 18:33:19 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4750d3f_c532aef6
UUID: e430ad80_4708ee9e
Bytes: 100
this code isn't called for symlinks; only regular files. (we do nothing for symlinks. is that okay?)

213:65-213:78
Tue Aug 25 02:46:45 2015 +0000
Author: Christopher Ferris <1019050@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4750d3f_7f482d81
Bytes: 173
Shouldn't this goto fail (assuming you add a fd = -1 after the close)? If do_unlink is true, the adb_unlink call from below is not called even though this is a failure case.

213:65-213:78
Tue Aug 25 03:25:32 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4750d3f_7f482d81
UUID: 4485f957_135247b7
Bytes: 169
but you're only supposed to unlink bad files, i think. if we get this far, what's on the fs is fine in every way --- we just weren't able to tell the client we finished.

324:8-325:21
Tue Aug 25 03:06:29 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 248c8586_3652ceb7
Bytes: 175
The old code would bail if writing the errmsg failed, but if it succeeded, it would return success, presumably keeping the sync service thread running. What do we really want?

337:19-337:25
Tue Aug 25 03:06:29 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 84253145_6142bd14
Bytes: 112
The old thread would only kill the sync service thread if it failed to write the errmsg. What do we really want?

