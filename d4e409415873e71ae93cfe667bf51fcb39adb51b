Revision: d4e409415873e71ae93cfe667bf51fcb39adb51b
Patch-set: 2
File: /COMMIT_MSG

7:0-7:3
Tue Dec 16 17:56:59 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c16380f0_69ba2596
Bytes: 4
logd

File: logd/LogTimes.h

71:4-72:29
Tue Dec 16 17:56:59 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 815d0834_87fd46c7
Bytes: 1022
Please no.

TL;DR

This will result in a slow logger port (serial console log, or other slow path) increasing memory pressure on the system. triggerSkip is used to tell the reader threads in an emergency (using up to double requested storage) to dump a series of entries rather than forwarding them so that the memory can be freed. This allows a reader range lock to clear so that pruning can progress.

We can not allow this to be bypassed or we could get into a (minor) Memory DoS attack should a reader thread be blocked.

Architectural question: Could the problem be that the writer thread is not waking up to reader thread(s) to process the skip? IS there something blocking the reader thread(s) from waking up? Eventually when we get to double the storage, we kill the reader thread, but up to that point we will be doing a lot of ignored mechanics burning CPU cycles. This code was added because bumping the errant reader threads alone was undesirable if they were merely slow.

NB: Android coding standard, use { }

71:4-72:29
Tue Dec 16 19:50:02 2014 +0000
Author: TraianX Schiau <1061958@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 815d0834_87fd46c7
UUID: e1d164e3_52413469
Bytes: 563
Yes sure, but in a normal execution scenario we will also have an oldest (this includes the scenario in which we have
only one client), so a value from which we start to skip should be set (bufferSize could be an idea).

Additionally should be taken into account:
- TimeEntry works on multiple buffers and pruning is done per buffer (skipAhead should be skipAhead[LOG_ID_MAX] set,updated and checked accordingly).
- clean should call prune with the current number of messages in the buffer;

Please let me know your opinion on this. So I can push a new patch-set.

71:4-72:29
Tue Dec 16 20:37:15 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e1d164e3_52413469
UUID: 41c2301f_3011064a
Bytes: 969
KISS and maintainability are the primary goals.

We start pruning/skipping at 10% over on a per-id basis, and we punt the reader if we are 100% over.

Skip is meant to be a coarse tool to provide a soft means of dealing with a reticent reader client that is behind by >100% of the buffer. The intent was to leave it to caller heuristics to decide by how much, or if to kill the reader's socket.

Leave the ULONG_MAX alone as it is KISS and means EVERYTHING, refining it to number of messages only means you will be creating edge or race conditions. Dealing with the edge conditions ala #2 was a fine move.

No value with accurate accounting given that prune request value will be 'very large' or 'roughly 10%'. By all means refine the guess, but if it takes more than a few ns to figure out, or is complicated to maintain, walk away.

NB: I am thinking of deprecating white and blacklists; not KISS and so far no one has used it. Also statistics needs to be KISS'd too.

