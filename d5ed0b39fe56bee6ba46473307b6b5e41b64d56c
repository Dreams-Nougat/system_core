Revision: d5ed0b39fe56bee6ba46473307b6b5e41b64d56c
Patch-set: 5
File: include/netutils/ifc.h

52
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///7U=
Bytes: 161
Add another parameter at the end specifying the gateway to use:

extern int ifc_add_route(const char *name, const char *addr, int prefix_length, const char *gw);

File: libnetutils/ifc_utils.c

234
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///8k=
Bytes: 125
Can you add a parameter, like so?

int ifc_add_ipv4_route(const char *name, in_addr_t dst, int prefix_length, in_addr_t gw) {

246
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///8g=
Bytes: 395
This block would then become something like the following:

    netmask = get_ipv4_netmask(prefix_length);
    init_sockaddr_in(&rt.rt_genmask, netmask);
    init_sockaddr_in(&rt.rt_dst, dst);
    rt.rt_flags = RTF_UP;

    if (prefix_length == 32) {
      rt.rt_flags |= RTF_HOST;
    }
    if (gateway != 0) {
      rt.rt_flags |= RTF_GATEWAY;
      init_sockaddr_in(&rt.rt_gateway, gw);
    }

271
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///8c=
Bytes: 67
This would then be:

    return ifc_add_ipv4_route(name, 0, 0, gw);

276
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///8Y=
Bytes: 69
And this would be:

    return ifc_add_ipv4_route(name, addr, 32, 0);

492
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///8U=
Bytes: 189
Similarly to the IPv4 case above, can you make this take an extra parameter, like so?

int ifc_add_ipv6_route(const char *name, struct in6_addr dst, int prefix_length, struct in6_addr gw) {

509
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///8Q=
Bytes: 400
This will then be something like the following:

    rtmsg.rtmsg_ifindex = ifindex;
    rtmsg.rtmsg_dst = dst;
    rtmsg.rtmsg_dst_len = prefix_length;
    rtmsg.rtmsg_flags = RTF_UP;

    if (prefix_length == 128) {
        rtmsg.rtmsg_flags |= RTF_HOST;
    }
    if (memcmp(&gw, &in6addr_any, sizeof(in6addr_any)) {
        rtmsg.rtmsg_flags |= RTF_GATEWAY;
        rtmsg.rtmsg_gateway = gw;
    }

535
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///8M=
Bytes: 113
Add a gateway parameter:

int ifc_add_route(const char *name, const char *dst, int prefix_length, const char *gw)

535
Tue Aug 10 05:05:53 2010 +0000
Author: Srinivas Naik <1004300@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA4n///8M=
UUID: AAAA4n///5A=
Bytes: 561
Thanks for the suggestions Lorenzo.
Small clarification before implementing this,
1) If ifc_add_route is used for adding host route, then "gw" will be empty address from java space right??

2) Similarly if ifc_add_route is used for adding default route, then "dst" will be empty address from java space right??

3) Also do we need to convert "dst" also to empty address in case if it is NULL as it is done for "gw" below? If so first we need to process the non NULL address to get the family type and build the empty address for the other NULL address using it?

535
Tue Aug 10 06:06:02 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA4n///5A=
UUID: AAAA4n///44=
Bytes: 1068
My thinking was that if gw is either NULL or a string specifying a zero address ("0.0.0.0" for IPv4, or "::" etc. for IPv6), then it signifies a directly connected route (i.e., what the old code called a "host route"). However, it's probably more correct to do this:

- If gw is NULL, don't set the RTF_GATEWAY flag.
- If gw is not NULL, set the RTF_GATEWAY flag and set rtmsg_gateway to the address specified by gw.

So I would do the following:

1. If addr is NULL or is not a valid IP address, return failure.
2. If prefix_len == 32 for IPv4, or 128 for IPv6, set the RTF_HOST flag.
3. If gw is not NULL:
  a. Convert gw to an IP address.
  b. If it is not a valid IP address, or it is not of the same family (IPv4 / IPv6) as addr (e.g., an IPv4 route with an IPv6 gateway), return failure.
  c. Set RTF_GATEWAY flag and set rtmsg_gateway to the IP address specified by gw.

The logic should be the same for IPv4 and IPv6.

Note that it's possible to have a host route that is reachable through a gateway, so it's possible to have both RTF_HOST and RTF_GATEWAY set.

535
Tue Aug 10 10:21:54 2010 +0000
Author: Srinivas Naik <1004300@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA4n///44=
UUID: AAAA4n///4g=
Bytes: 822
Please correct me if my understanding is wrong:
If i check for addr to NULL and return failure, how to add just a default route? My understanding is that, to add just a default route, addr will be null and gw will be gateway address.
Also in ifc_create_default_route() we are calling ifc_add_ipv4_route(name, 0, 0, gw) where the addr is null.

Please let me know if this is OK to do:
1. If both addr and gw are NULL/INVALID return failure.
2. If addr is not NULL and prefix_len == 32/128 for IPv4/IPv6 respectively, set the RTF_HOST flag.
3. If gw is not NULL:
    a. Convert gw to an IP address.
    b. If addr is present and gw is not of the same family (IPv4 / IPv6) as addr (e.g., an IPv4 route with an IPv6 gateway), return failure.
    c. Set RTF_GATEWAY flag and set rtmsg_gateway to the IP address specified by gw.

535
Tue Aug 10 16:40:28 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA4n///4g=
UUID: AAAA4n///3g=
Bytes: 843
Actually, I am suggesting that the function should always require a non-null destination, but should accept a null gateway. You can always use "0.0.0.0" or "::" and a prefix length of 0 to indicate the default.

So, for IPv4 you could do:

  ifc_add_route("wlan0", "0.0.0.0", 0, "192.168.1.254");    // default via gateway 192.168.1.254 on wlan0
  ifc_add_route("wlan0", "10.1.99.5", 32, NULL);            // host 10.1.123.4 via wlan0
  ifc_add_route("wlan0", "10.1.123.4", 32, "192.168.1.10"); // host 10.1.123.4 through gateway 192.168.1.10 on wlan0

If you think it simplifies the code to never accept any null arguments, or to accept both null gateways and null addresses, that's fine too. The important thing is that RTF_GATEWAY is set iff there is a real gateway and that RTF_HOST is set iff the prefix length is the maximum (32 or 128).

535
Tue Aug 10 17:14:43 2010 +0000
Author: Srinivas Naik <1004300@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA4n///3g=
UUID: AAAA4n///2k=
Bytes: 76
Thanks for the clarifications Lorenzo. Will upload changes as you suggested.

538
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///8I=
Bytes: 133
Keep track of IPv4 and IPv6 gateways as well:

    struct sockaddr_in ipv4_addr, ipv4_gw;
    struct sockaddr_in6 ipv6_addr, ipv6_gw;

540
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///8A=
Bytes: 133
Add an addrinfo structure for the gateway and rename result to addr_ai for consistency:

    struct addrinfo hints, *addr_ai, *gw_ai;

552
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///8E=
Bytes: 726
Convert the gateway to a socket address as well. For convenience, if the gateway is NULL, convert it to an empty address.

    if (gw == NULL) {
        if (addr_ai->ai_family == AF_INET6) {
            gw = "::";
        }
        if (addr_ai->ai_family == AF_INET) {
            gw = "0.0.0.0";
        }
    }

    ret = getaddrinfo(gw, NULL, &hints, &gw_ai);
    if (ret != 0) {
        printerr("getaddrinfo failed: invalid gateway %s\n", gw);
        freeaddrinfo(addr_ai);
        return -1;
    }

    if (addr_ai->ai_family != gw_ai->ai_family) {
        printerr("ifc_add_route: different address families: %s and %s\n", addr, gw);
        freeaddrinfo(addr_ai);
        freeaddrinfo(gw_ai);
        return -1;
    }

554
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///78=
Bytes: 314
After this memcpy, convert the gateway to a socket address array as well:

        memcpy(&ipv6_addr, result->ai_addr, sizeof(struct sockaddr_in6));
        memcpy(&ipv6_gw, gw_ai->ai_addr, sizeof(struct sockaddr_in6));
        ret = ifc_add_ipv6_route(name, ipv6_addr.sin6_addr, prefix_length, ipv6_gw.sin6_addr);

558
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///74=
Bytes: 276
And do the same for IPv4:

        memcpy(&ipv4_addr, result->ai_addr, sizeof(struct sockaddr_in));
        memcpy(&ipv4_gw, gw_ai->ai_addr, sizeof(struct sockaddr_in));
        ret = ifc_add_ipv4_route(name, ipv4_addr.sin_addr.s_addr, prefix_length, ipv4_gw.sin_addr.s_addr);

565
Tue Aug 10 00:23:09 2010 +0000
Author: Lorenzo Colitti <1000835@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA4n///7Y=
Bytes: 30
Also:
    freeaddrinfo(gw_ai);

