Revision: 0c1c8430c92a8d2e0a8eb3f92676dcbc3c5aebac
Patch-set: 1
File: include/system/window.h

929
Tue Mar 24 20:35:40 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a3f6a249_ec64f34b
Bytes: 36
What about out-of-bound coordinates?

929
Tue Mar 24 20:46:58 2015 +0000
Author: Dan Stoza <1043625@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a3f6a249_ec64f34b
UUID: 4665f4c2_0e8d7b83
Bytes: 290
It's a fair question. I'm not sure what semantics we would expect here. While I haven't implemented it, I think the most reasonable thing would be to clamp the coordinates against the buffer size in BufferQueueProducer (which is the first time we have easy access to the buffer dimensions).

928:56-929:70
Mon Mar 30 21:57:00 2015 +0000
Author: Jesse Hall <1010672@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 837a7ea8_e59979c5
Bytes: 335
I vaguely remember talking about this, but if so I don't remember why we chose bottom-left origin. Radiance is going with upper-left origin for window surfaces, so one or the other is going to have to y-flip the region. Given that everywhere else in the platform/framework we use upper-left origin, I'd be inclined to do that here too.

928:56-929:70
Wed Apr 15 15:59:37 2015 +0000
Author: Dan Stoza <1043625@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 837a7ea8_e59979c5
UUID: 03868e96_7893172a
Bytes: 180
After offline discussions, it sounds like we're going to have to go with bottom-left for this interface, since there's just no way to flip it before native Surface at the earliest.

931
Tue Mar 24 20:35:40 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c3fb9632_c771140c
Bytes: 90
seems like a struct typedef might be worth it (e.g. struct ANativeWindowRect or some such)

931
Tue Mar 24 20:46:58 2015 +0000
Author: Dan Stoza <1043625@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c3fb9632_c771140c
UUID: a68a309d_7100a0b8
Bytes: 485
This is basically a direct mapping of the following EGL extension:

https://www.khronos.org/registry/egl/extensions/KHR/EGL_KHR_swap_buffers_with_damage.txt

My goal with this change was to pass things as directly as possible here, do some packaging in native Surface, and the rest in BufferQueueProducer. We could do this packaging further up the stack (basically in the EGL wrapper), but I don't anticipate anyone but the EGL wrapper using this API, so it's a "six of one" situation.

931
Tue Mar 24 20:52:19 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a68a309d_7100a0b8
UUID: 23eb9264_0a681f1c
Bytes: 157
I wouldn't be too surprised if someone wanted to use it outside of EGL in the future (decoders, CPU producers, etc?), it seems like a good optimization idea.

931
Wed Apr 15 15:59:37 2015 +0000
Author: Dan Stoza <1043625@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 23eb9264_0a681f1c
UUID: 904c868c_8dd32953
Bytes: 77
Okay. I swapped it to use the rect class already defined in this header file.

