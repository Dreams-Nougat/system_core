Revision: 5cb6ae78fdeebb40d5e636bae26772f7730d9bf4
Patch-set: 2
File: adb/adb.cpp

987:24-987:38
Thu Aug 27 20:13:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 84253145_a7521b5f
Bytes: 932
I think that find_transport can find a transport while holding the lock, then it releases the lock, then another thread destroys the transport and then t points to a deallocated transport. Basically, find_transport does not increment the refcount, thus once it leaves the lock, the transport can be destroyed. In my original change, I considered modifying find_transport to increment the refcount, but that would mean that when releasing the refcount, the refcount could drop to zero on the adb disconnect thread, which would be a change from the current code, where it drops to zero on the input_thread or output_thread (in other words, it might be potentially more destabilizing). So it seems like you have to either do everything under the lock, or else increment the refcount before leaving the lock and then deal with any potential destabilization (which might be ok, but not my call to make since I'm not the component owner).

File: adb/transport.cpp

331:5-331:19
Thu Aug 27 20:13:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 248c8586_73cff357
Bytes: 307
This can no longer take a nullptr. That sounds ok as long as you reviewed all the callers to make sure that is impossible.

This now does the kick under the lock. In theory I think that should be ok because other code already does the kick under a lock, but I haven't really looked into it deeply. Thoughts?

643:10-643:22
Thu Aug 27 20:13:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 046221c0_5af1f107
Bytes: 94
This sounds good as long as you reviewed all the callers to verify that nullptr is impossible.

954:12-954:26
Thu Aug 27 20:13:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 248c8586_33f2cb91
Bytes: 118
As I mentioned before, this function is broken because the found transport can be destroyed once the lock is released.

