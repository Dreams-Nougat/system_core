Revision: 6f308c4aafabe08b0ccbeca7b9c13897385be546
Patch-set: 2
File: logd/LogKlog.cpp

608:4-608:27
Fri Aug 05 20:54:50 2016 +0000
Author: Alexey Polyudov <1097918@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d97e679c_7e8185f6
Bytes: 29
nit: condition is always true

608:4-608:27
Fri Aug 05 21:26:02 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d97e679c_7e8185f6
UUID: d97e679c_fe49158b
Bytes: 333
Not if the buffer is prematurely empty (*p is a nul) or rather if the dmesg contains an embedded nul (we had this coming from a partner kernel).

Will also skip out if the character is a newline, which happens _often_ in vendor code that wants to make itself _loud_ by adding a bunch of empty lines. We do not care to log that noise.

608:4-608:27
Fri Aug 05 21:36:18 2016 +0000
Author: Alexey Polyudov <1097918@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d97e679c_fe49158b
UUID: d97e679c_7e966598
Bytes: 414
condition is true here, because we tested it in line 598;
we went through line 601 check also (and this pruved that if we made it to line 604 then (p < &buf[len]) in line 598 is true); this means that (isspace(*p) || !*p) condition in line 598 is false, and consequently that the opposite of it is true: (!isspace(*p) && *p) which is exactly the check in line 608.
But again, it is only a nit; no harmful behavior.

609:8-609:33
Fri Aug 05 22:07:41 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d97e679c_fe8b5519
Bytes: 127
These do not appear after this block, optimizer will have no problems with this, so I will take your nit and save an indent ...

632:12-632:22
Fri Aug 05 20:54:50 2016 +0000
Author: Alexey Polyudov <1097918@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d97e679c_3ef6ad91
Bytes: 53
this could be out-of-bounds access, if taglen is zero

632:12-632:22
Fri Aug 05 21:26:02 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d97e679c_3ef6ad91
UUID: d97e679c_de153950
Bytes: 485
not sure if I want to expend yet another indent on this minor transgression, let me see if I can make this cleaner ..

Regarding my use of minor transgression: The issue we have is either we progress beyond the buffer bounds until we hit a protective page boundary, or we don't and then scribble a large swath of buffer-beyond-bounds into an output. So this is a minor transgression as it will trigger neither of these catastrophic behaviors; but it can cause corrupted output content.

638:12-638:34
Fri Aug 05 20:54:50 2016 +0000
Author: Alexey Polyudov <1097918@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d97e679c_1efbb169
Bytes: 191
the only guarantee here about size is "size > 0".
the code below makes certain assumptions about size, without proving them. Calculating (size - 5) may render unwanted results if size is < 5.

638:12-638:34
Fri Aug 05 21:26:02 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d97e679c_1efbb169
UUID: d97e679c_be1cfd77
Bytes: 37
Yes, we need to check if size > 5 ...

702:12-702:57
Fri Aug 05 19:56:57 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d97e679c_fb49278b
Bytes: 104
Oh well, trust the optimizer, the repeated checks above in each other case saves us resorting to a goto.

718:8-718:19
Fri Aug 05 19:56:57 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d97e679c_bb43af69
Bytes: 58
I am reserving the right to make this a ssize_t in future.

