Revision: a7c6f13070c9826c85a4324fd156455bdb66dbc8
Patch-set: 1
File: adb/commandline.cpp

457:12-460:13
Mon Oct 12 23:00:36 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff32061b_aab33322
Bytes: 334
This may be a dumb question, but why isn't this just:

if (args->protocol) {
  // This method would send some protocol msg to cause adbd
  // to do close(fd) so that the subprocess would get read() == 0
  args->protocol->Close(...);
} else {
  // close the socket, so the other side will see recv() == 0
  adb_close(args->write_fd);
}

457:12-460:13
Tue Oct 13 16:23:12 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff32061b_aab33322
UUID: 7fa9b65d_bf1ce77e
Bytes: 560
Not a dumb question at all, I was attempting to make that exact approach work for a while :)

Closing the socket entirely is great because this loop won't hang, but it could miss an arbitrary amount of return data. For example if we were to send a lot of data without the shell protocol:

  $ cat <large_file> | adb shell -x cat

this stdin loop will hit the end of input and close the FD before all the return data is received.

Neither option is ideal but IMO it's better to be predictable and cumbersome than sometimes work and sometimes silently drop data.

457:12-460:13
Tue Oct 13 20:56:28 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7fa9b65d_bf1ce77e
UUID: 9fae6a64_a0ee06e0
Bytes: 1301
Given your cat example, why not do a socket half-close with shutdown(SHUT_WR), since that's what it was designed for? And as you've explained, you're already doing that in adbd? In other words:

if (args->protocol) {
  // This method would send some protocol msg to cause
  // adbd to do shutdown(fd, SHUT_WR) so that the subprocess
  // would get read()==0, but the subprocess would still
  // be able to write, and adbd would still be able to read from
  // the subprocess.
  args->protocol->Close(ShellProtocol::kIdStdin); // this is basically already what you're doing
} else {
  // cause the other side to see recv()==0, but the other side
  // can still write to the fd.
  shutdown(args->write_fd, SHUT_WR);
}

Though one problem I see with this is that I've recently found that on Windows, if the adb client does close(sock) or shutdown(sock, SHUT_WR) before the adb server, the client socket stays in TIME_WAIT and eventually the adb client will run out of free ports and it will be unable to connect to the adb server until TIME_WAIT expires. I've got a code review to solve this for a variety of places in adb, but adding the shutdown() above might break my fix, but it still might be preferable to do the shutdown() call anyway since it will make 'adb shell echo hello' not hang.

Thoughts?

570:8-570:21
Mon Oct 12 23:00:36 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f30ba11_4b2eedc8
Bytes: 136
Couldn't stdin_read_thread() still be using `fd` (aka args->write_fd) concurrently? Is it safe to close it here without synchronization?

570:8-570:21
Tue Oct 13 16:23:12 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f30ba11_4b2eedc8
UUID: bfb7aeb4_f6cfeeb0
Bytes: 422
Hmm you're absolutely right, thanks! I'd love to properly exit the stdin read thread before this point but it seems tricky to do portably since afaik Windows doesn't have signals to interrupt reads and can't use select() on stdin.

For now I think I'll just leave this FD open, which isn't great, but seems to be the current behavior for interactive `adb shell`. I'll have to take some time and revisit this in another CL.

570:8-570:21
Tue Oct 13 20:56:28 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bfb7aeb4_f6cfeeb0
UUID: 9fae6a64_804c2ab3
Bytes: 386
Does it really make sense to have this thread cause the stdin_read_thread to exit? Or does it make more sense for this thread to wait for the stdin_read_thread to exit? The latter is not too hard to do cross-platform (basically, pthread_join on *nix, and WaitForSingleObject(thread_handle) on Windows).

But yeah, I don't see this as super-critical, so fine to leave it for another day.

File: adb/shell_service.cpp

511:24-511:70
Mon Oct 12 23:00:36 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff32061b_27abdec7
Bytes: 175
Just a reminder to test this error case. I found that (on Windows at least), shutdown() returned an error when the socket was no longer connected, which somewhat surprised me.

511:24-511:70
Tue Oct 13 03:20:11 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff32061b_27abdec7
UUID: ff32061b_750f50b5
Bytes: 226
Naive question: why do you need to call shutdown(SHUT_WR) here if close() will be called in a moment anyway? I thought that shutdown(SHUT_WR) is typically only useful if you're going to read()/recv() before close()'ing the fd.

511:24-511:70
Tue Oct 13 16:23:12 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff32061b_750f50b5
UUID: 1f30ba11_916e662c
Bytes: 256
This code is device-side only, doing exactly as you describe; this closes the subprocess stdin FD, but leaves stdout and stderr open so that the subprocess can continue to spit out data if necessary. I only close the entire FD if the shutdown() call fails.

511:24-511:70
Tue Oct 13 20:56:28 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f30ba11_916e662c
UUID: 9fae6a64_40563243
Bytes: 30
Ah, ok, thanks for explaining.

File: adb/sysdeps.h

491:23-491:58
Mon Oct 12 23:00:36 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff32061b_c7b9521e
Bytes: 113
Thanks, I've been thinking of adding this too. This is what should have been there originally in the first place.

491:23-491:58
Tue Oct 13 16:23:12 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff32061b_c7b9521e
UUID: 3fa3be81_b2873e4f
Bytes: 188
Sorry to disappoint, I'm only defining it for Linux at the moment :( I only need this on the device side for this CL and didn't want to worry about any Windows stuff that I didn't have to.

File: adb/sysdeps_win32.cpp

3273:0-3275:13
Mon Oct 12 17:14:19 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bfb7aeb4_6794b213
Bytes: 259
(Spencer maybe you'll have some insight here? My Windows programming is weak)

Does this seem like a reasonable value? I couldn't find much information on why this happens but it seems to be the same issue as this: http://sourceforge.net/p/sevenzip/bugs/645/.

3273:0-3275:13
Mon Oct 12 23:00:36 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bfb7aeb4_6794b213
UUID: df39c202_c9e4c904
Bytes: 50
Let me look into this further and get back to you.

3273:0-3275:13
Tue Oct 13 02:10:22 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: df39c202_c9e4c904
UUID: df39c202_34266886
Bytes: 1475
Ok, here's what I've learned: On Windows 7, reading from a console uses the LPC subsystem of Windows which happens to use a 64k "heap" which is chopped up for IO operations. In practice, 31366 bytes seems to be the max allowed size. 16384 would probably be fine to use, but I don't see any point: a conservative 4096 is fine since a larger value doesn't buy us anything since this is just console IO.

Windows 10 doesn't seem to have this issue since they rewrote the console stuff. I didn't try Vista or Win8 and I think for simplification purposes it is fine to use the same size on all Windows versions.

I do have one suggestion to make: instead of if (fd == STDIN..., how about something like:

// Check if this is a console. This may also catch devices like NUL, but
// that is ok as we just want to avoid pipes and files which don't need
// size limiting. This isatty() test is very simple and quick
// and doesn't call the OS.
if (isatty(fd)) {
  // On older versions of Windows (definitely 7, definitely not 10),
  // ReadConsole() with a size >= 31367 fails, so limit the read size.
  if (len > 4096) {
    len = 4096;
  }
}

The idea is to use the original size for pipes & files and only do this weirdness for consoles (and corner cases that isatty() gets wrong, but that aren't important).

Please feel free to edit my suggestion as you like (i.e. you don't need to use my exact text, you can combine, edit, etc.). Thanks.

P.S. I don't envy your test matrix. :)

3273:0-3275:13
Tue Oct 13 16:23:12 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: df39c202_34266886
UUID: bfb7aeb4_a1d7f221
Bytes: 57
Will do, thanks! Really appreciate you looking into this.

