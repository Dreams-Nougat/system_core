Revision: 4627cee345632f69bbfc3576014038cbf877aaec
Patch-set: 2
File: fastboot/fastboot.cpp

238:8-238:24
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 40933818_524842b1
Bytes: 331
If crate_transport() tries to make a TCP connection and fails this will fall through and then attempt to make a USB connection, which is almost certainly not what the user wanted.

We probably just want to return |transport| here whether it's null or not, and then add handling at the call site to error out if nullptr is returned.

File: fastboot/tcp_linux.cpp

46:0-49:2
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e06d0cee_14ae2ca9
Bytes: 225
If you want to just put sockfd directly as a member in LinuxTcpTransport that might be simpler. I only kept the "handle" structures in the USB code to avoid having to do a large refactor when I introduced the Transport class.

46:0-49:2
Tue Dec 08 14:26:53 2015 +0000
Author: Viorel Suman <1047984@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e06d0cee_14ae2ca9
UUID: 60f2fca8_f1f402ee
Bytes: 4
Done

66:33-66:50
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e06d0cee_b456604f
Bytes: 241
Prefer more descriptive variable names instead of prefixing _ for new code, maybe something like this:

  ssize_t LinuxTcpTransport::Write(const void* data, size_t len) {
    unsigned char* char_data = reinterpret_cast<unsigned char*>(data);

66:33-66:50
Tue Dec 08 14:26:53 2015 +0000
Author: Viorel Suman <1047984@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e06d0cee_b456604f
UUID: 800b7060_cfb2fd1e
Bytes: 4
Done

68:4-68:54
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e0842cce_16b38c56
Bytes: 77
Prefer pointer next to the type for new code (see above comment for example).

68:4-68:54
Tue Dec 08 14:26:53 2015 +0000
Author: Viorel Suman <1047984@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e0842cce_16b38c56
UUID: a0d6b40a_03b870e6
Bytes: 4
Done

76:12-76:46
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 00486077_3295ae20
Bytes: 142
Use TEMP_FAILURE_RETRY to handle EINTR, and I think we can drop EAGAIN handling if we're always blocking, to get rid of this switch statement.

76:12-76:46
Tue Dec 08 14:26:53 2015 +0000
Author: Viorel Suman <1047984@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 00486077_3295ae20
UUID: e0feec6e_d5b8ce91
Bytes: 4
Done

78:0-80:24
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 40933818_b7a6582d
Bytes: 89
Probably better to return -1 here and let the main loop decide how to handle the failure.

78:0-80:24
Tue Dec 08 14:26:53 2015 +0000
Author: Viorel Suman <1047984@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 40933818_b7a6582d
UUID: 40edf8c8_504eb24f
Bytes: 4
Done

97:0-98:75
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 00486077_52902a30
Bytes: 119
I assume this is to get around hardware limitations, is it necessary to repeat here? Might as well leave it out if not.

101:0-102:20
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 009dc025_af0b61aa
Bytes: 79
Seems better to return |count| here and let the caller decide how to handle it.

105:12-105:46
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 40933818_97e0fc4f
Bytes: 28
Same re: TEMP_FAILURE_RETRY.

107:0-108:24
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 204d6487_38747117
Bytes: 10
Return -1.

112:15-112:18
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 00486077_526b8a9c
Bytes: 2
n?

115:9-115:43
Mon Dec 07 20:49:50 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 60e03ce1_0165cc60
Bytes: 941
What's the bug here and do we have to replicate it?

I'm not super familiar with USB internals, but it seems like this is just saying "if we get a smaller packet than we expected, we're done". This seems fine if USB packets aren't fragmented (though I'm not positive this is the case) since you're guaranteed to get everything the device sent.

However TCP can definitely fragment packets right? If fragmentation happens here and the read() returns less than was sent by the device, this will exit early. The callers of this function make no attempt to re-read if they don't get all the bytes they want so this would likely cause a failure.

The expectation seems to be that Read() may return fewer than |len| bytes, but it will always return everything the device has sent. I believe to achieve the same guarantee in TCP we'll have to add some sort of protocol indicating packet sizes so we can keep reading here until we get a full packet.

115:9-115:43
Tue Dec 08 14:25:53 2015 +0000
Author: Viorel Suman <1047984@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 60e03ce1_0165cc60
UUID: 60f2fca8_11fc2ed9
Bytes: 495
Yes, it was related to the fact that passed |len| parameter is the maximum number of bytes that might be stored in the passed |data| buffer. In protocol.cpp:check_response() method the transport read method (line 55) always get the length of "status", which is 64 bytes. However we cannot expect to get 64 bytes all the time, given the fact that, IE, a "DATA" status will always return 12 bytes only. Therefore I have simplified LinuxTcpTransport::Read() method to the form that can be seen now.

