Revision: d575b3c779e412b2666b047d3bddb76f65e81a62
Patch-set: 2
File: crash_reporter/crash_reporter.cc

82:1-103:1
Wed Aug 19 21:25:56 2015 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4fb1585_6d9ca34a
Bytes: 75
Given that you're already using libchromeos, can you use chromeos::Process?

82:1-103:1
Wed Aug 19 21:55:29 2015 +0000
Author: Steve Fung <1076778@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4fb1585_6d9ca34a
UUID: 64591d73_72a3c7fb
Bytes: 952
My first implementation, I used chromeos::ProcessImpl to run the command.  However the code wound up being messier than I liked.  The issue wound up being, calling process.Run() blocks here until the process finishes.  Calling process.Start() instead allows it to not block, however if nothing calls process.Wait(), once crash_reporter finishes running it quits the process without it finishing, which in practice happens before dbus-send can actually send the signal.  The way around that, then would be to store the process in the class and call process.Wait() at the very end of execution... however the way the different collectors calls are structured, this CountUserCrash function is stored as a function pointer and called in several different locations based on the collector.  Modifying each collector to handle that independently from each other was much messier and harder to follow/read, than using vfork+execve which is all self-contained.

82:1-103:1
Wed Aug 19 22:03:20 2015 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64591d73_72a3c7fb
UUID: e4aeed64_9a032f85
Bytes: 91
But you're not wait()ing on the child here, are you?

Also, why vfork and not regular fork?

82:1-103:1
Wed Aug 19 22:25:41 2015 +0000
Author: Steve Fung <1076778@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4aeed64_9a032f85
UUID: 243ac5f6_4c839c5c
Bytes: 939
No, I'm not explicitly wait()ing here.  But in my testing (I replaced the dbus-send call with `wait 10`), after the vfork+execve, the rest of crash_reporter finished running immediately, then waited until the child finished before exiting.

I used vfork instead of regular fork to guarantee not having to copy all the excess process data that would just be wiped out during the execve.  I believe (but am not entirely sure) that it also ties into the previous quesion about wait()ing.  A vfork suspends the parent until either an _exit or successful execve call is made.  Once the execve call is successful it wakes back up the parent as it won't have resource contention anymore.  A fork call does not suspend the parent, and I believe then would require a wait() call to reap the child process.  If you feel strongly about using fork instead of vfork, and are sure that we'll always have a copy-on-write version of fork, I can switch it.

82:1-103:1
Wed Aug 19 22:34:11 2015 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 243ac5f6_4c839c5c
UUID: 243ac5f6_92b01a2c
Bytes: 610
Is there an explicit call to wait() anywhere in the code? Where is that waiting-before-exiting happening?

Is dbus-send getting reparented to init?

As for fork vs vfork, this is the manpage:

"Under Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the parent's page tables,  and to create a unique task structure for the child."

Also, I don't think you can avoid wait()ing on vfork. Even when your child process goes through execve(), you still need to reap it; if not, it will get reparented to init when you exit.

82:1-103:1
Wed Aug 19 22:52:49 2015 +0000
Author: Steve Fung <1076778@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 243ac5f6_92b01a2c
UUID: a4fb1585_d85d93c2
Bytes: 385
You're right, looking at the logs closer, dbus-send was getting reparented to init, and then cleaned up.  I'm going to take a step back on this one and re-look at it... if I have to propagate the PID back to wait() on it at the very end of execution, I'll likely just abandon this CL and go back to my initial chromeos::ProcessImpl one and propagate the process through the collectors.

82:1-103:1
Wed Aug 19 23:00:38 2015 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4fb1585_d85d93c2
UUID: 64591d73_6593ff2d
Bytes: 118
Since we're getting close to EAP, if the chromeos::Process CL gets too complicated, feel free to skip until after EAP.

82:1-103:1
Tue Sep 01 07:09:34 2015 +0000
Author: Mike Frysinger <1040868@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64591d73_6593ff2d
UUID: 0484e2ca_56db5406
Bytes: 499
i'm pretty sure the reparent issue already exists in our current system/background implementation, so i wouldn't really use that particular point as a blocker.  although it still feels wrong to let it zombie/reparent.

it could be squelched by calling signal(SIGCHLD, SIG_IGN) in the parent (crash_reporter), but that'd interfere with other uses of chromeos::Process (which this code base does).  the kernel will then reap the child immediately and not let it go to zombie state/reparent it to init.

82:1-103:1
Tue Sep 01 07:13:58 2015 +0000
Author: Mike Frysinger <1040868@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0484e2ca_56db5406
UUID: 644d9e85_2baadded
Bytes: 623
although, for the existing chromeos::Process users, we reap them immediately.  so what if, at the end of crash_reporter's main(), we do:

 /* Reap any outstanding zombies. */
 while (waitpid(-1, &status, WNOHANG) >= 0)
   continue;

if the dbus process did actually crash/hang, we *do* want to let crash_reporter exit and have it reparent to `init`.  as long as crash_reporter continues to stay alive handling a user crash, the kernel will not free up the core dump or notify the processes watching the crashing process.

and saying that out loud, maybe we should just let it always zombie/reparent and not worry about it ?

