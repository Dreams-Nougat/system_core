Revision: 96720b368b4e671a22dbf36c9f36b5b1e413e5e8
Patch-set: 1
File: include/log/log.h

829:0-829:22
Fri Dec 16 19:34:37 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_e3c4dc33
Bytes: 315
Mingw not happy with this :-(

/usr/local/google/buildbot/src/android/master/prebuilts/gcc/linux-x86/host/x86_64-w64-mingw32-4.8/x86_64-w64-mingw32/include/c++/4.8.3/atomic:804:5: error: ‘std::__atomic_is_lock_free’ declared as an ‘inline’ variable
     atomic_is_lock_free(const atomic<_ITp>* __a) noexcept

838:44-838:70
Fri Dec 16 19:34:37 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_6371acf7
Bytes: 579
If we remove the need for the caller to even know about atomics. The fact that it is illegal to abstract this to a uint64_t since one can not guarantee it is aligned properly to cast to atomic_uint_fast64_t. We have a few choices:

1) uint32_t works on all architectures we care about, can we get by with 32 bits? Also, you can use include <cutils/atomic.h> which only supports 32-bit atomics.
2) create a type that is 128 bits in size, and perform alignment internally to guarantee atomic operations <ick>
3) Do not support caller-supplied state, always global, all the time ...

849:19-849:23
Fri Dec 16 19:34:37 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_43acb06b
Bytes: 4
uint

