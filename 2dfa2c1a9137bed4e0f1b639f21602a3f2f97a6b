Revision: 2dfa2c1a9137bed4e0f1b639f21602a3f2f97a6b
Patch-set: 1
File: logd/LogTimes.cpp

123
Fri Aug 08 16:07:03 2014 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f6dbe336_3c11082d
Bytes: 34
why wouldn't you just return NULL?

123
Fri Aug 08 16:30:38 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6dbe336_3c11082d
UUID: 16c87774_962dac80
Bytes: 1115
I choose so to be pedantic about directly calling pthread_exit to be explicit about the paths.

pthread_cleanup_push() (and, if memory serves, other historically similar entities) is not what you think it is (I know you know what it is ;->). It is a (sometimes) dysfunctional block context to pthread_cleanup_pop and is required. However, historically there is a difference in thread locking when processing the cleanup operations within the context of pthread_exit and when pthread_cleanup_pop is called out in the thread just before exit. The alternative is:

    pthread_cleanup_pop();
    return NULL;

Which has a difference in atomicity because the thread is still 'alive' until return NULL, but the thread is 'dead' while the cleanup is being called in pthread_exit. Since then I have preferred:

    pthread_exit(NULL);
    pthread_cleanup_pop();
    return NULL;

I was bitten by this (circa 2002, port to *all* UNIXii) difference and I am still smarting over it.

I know, this is a decade later, and Linux _or_ Bionic is our target. If you are confident I am holding on to too much history, I'll relax ...

123
Fri Aug 08 16:39:45 2014 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16c87774_962dac80
UUID: f6dbe336_bc5998c1
Bytes: 512
no, you couldn't write

    pthread_cleanup_pop(true);
    return NULL;

because, as you say, the pop is really a "} while".

you'd just return NULL here (which is equivalent to calling pthread_exit(NULL) but less weird), and then you'd

    pthread_cleanup_pop(true);
    return NULL;

at the end (i.e. just remove the pthread_exit and the NOTREACH).

that's exactly the same because the return NULL is equivalent to pthread_exit(NULL), and the first thing that pthread_exit does is call your cleanup functions.

123
Fri Aug 08 16:53:46 2014 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6dbe336_bc5998c1
UUID: 360c9b77_44d9c204
Bytes: 1093
You misunderstand me. Let me try to rephrase. I am still siding on complying, just want to make it clear so that you understand the reasoning and can confirm we are both in sync.

'here' return NULL ok ... yes, only done here to *match* the bottom in pedantic operations. It always incurs a twinge of pain when the mid-routine exit differs from the exit at the bottom.

But the point is:

    pthread_cleanup_pop(true);
    return NULL;

at the bottom is *not* the same thing as the cleanup is done in the context of the thread, and not in the context of the 'exit'. If we want it to be performed in the 'exit' rather than in the contest of the thread:

    return NULL;
    pthread_cleanup_pop(true);

-or less strange-

    pthread_exit(NULL);
    pthread_cleanup_pop(true);
    return NULL;

eg: one of the problems (and I must admit this has more to do with the previous code which ran transitory threads, rather than this code which runs a persistent thread) is that the former can lead to more VSS taken under heavy load because the stack cleanup is no longer atomic in the general case.

157
Fri Aug 08 16:07:03 2014 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 360c9b77_c13f64f1
Bytes: 9
likewise.

