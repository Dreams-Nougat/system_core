Revision: 7e8a311976229c59d4bce973ce97ab689e2376ce
Patch-set: 5
File: adb/usb_libusb.cpp

129:9-129:15
Sat Oct 01 01:42:04 2016 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 425b693f_89e9d0a7
Bytes: 371
atomic variables are hard to use and understand. There are already three atomic variables in usb_handle, and two variables with mutex in themselves (read/write), maybe using a mutex in usb_handle and removing atomics is a better way. It is also what we did in usb_linux.cpp.
But I don't know if you have any special consideration (like for doing usb_read and usb_write?).

163:43-163:58
Sat Oct 01 01:42:04 2016 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 425b693f_4622a762
Bytes: 103
why recursive_mutex? Can we replace it with a normal mutex, which is easier to understand and maintain?

165:20-165:38
Sat Oct 01 01:42:04 2016 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 425b693f_e6087be2
Bytes: 21
no need to be global?

281:56-281:73
Sat Oct 01 01:42:04 2016 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 425b693f_66dc8b3b
Bytes: 40
It seems being hold for a too long code?

390:8-390:92
Sat Oct 01 01:42:04 2016 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 425b693f_c98fc827
Bytes: 339
Normally, to signal an event, we use a boolean flag in addition, like below:

waiter:
unique_lock lock(mutex);
while (!flag) {
  cv.wait(lock);
}

producer:
unique_lock lock(mutex);
flag = true;
cv.notify_one();

This is because cv.wait() can be waked Spuriously. see http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_cond_wait.html

509:16-509:21
Sat Oct 01 01:42:04 2016 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 425b693f_89ff904c
Bytes: 57
why close it twice? we have closed it in usb_kick, right?

