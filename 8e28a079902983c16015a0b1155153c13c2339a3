Revision: 8e28a079902983c16015a0b1155153c13c2339a3
Patch-set: 3
File: include/nativebridge/native_bridge.h

149:39-149:60
Wed May 06 03:55:56 2015 +0000
Author: Jinghui Gu <1051763@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d36f5df_d2654491
Bytes: 145
Can we merge this new interface at the end of existing NativeBridgeCallbacks? Because we don't want to keep forward-compatible for native bridge.

149:39-149:60
Wed May 06 04:16:04 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d36f5df_d2654491
UUID: 8d1e2d58_092dd98f
Bytes: 461
Please explain why. Please also remember that this interface is not meant to be Intel-centric.

1) I much rather prefer it that way. If a vendor chooses, this supports it. Houdini is still free to fail initialization to avoid this.

2) I'm getting mixed signals here, as Eric didn't complain.


There is an argument to merge this into the primary structure, as L libnativebridge isn't designed forward-compatible. But that isn't a particularly good reason IMHO.

149:39-149:60
Wed May 06 04:26:58 2015 +0000
Author: Jinghui Gu <1051763@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d1e2d58_092dd98f
UUID: 2d39c1d0_117bcc3c
Bytes: 362
Hi Andreas,
Yes. You're right. The native bridge is a general component.
But for every impl of native bridge, the compatibility issue is not only about the interface. For every dev of native bridge, they have to consider the status of more other Android components. So the forward-compatibility becomes useless. Instead, a clear interface should be much helpful.

149:39-149:60
Wed May 06 05:06:47 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d39c1d0_117bcc3c
UUID: 8d1e2d58_e98dfd03
Bytes: 477
I find that a very Houdini-centric answer. Yes, Houdini provides stubs/trampolines/whatever you call them for many (all) of the libraries in /system. But that is purely a performance-point implementation-detail IMHO. It is perfectly possible to translate *any* call and thus be forward-compatible, as you *can* be agnostic of any library.

As the initialization failure is a workable solution for a bailout, you still don't really convince me here why we should not aim for it.

149:39-149:60
Wed May 06 07:11:41 2015 +0000
Author: Jinghui Gu <1051763@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d1e2d58_e98dfd03
UUID: 2d39c1d0_11e18c4d
Bytes: 408
For fail initialization solution, how does houdini check the version of libnativebridge? Do you mean there's another new interface out there? Or, houdini should provide a new callback?

For the impl of v2 interface, it's OK if you think current solution is better than all-in-one. BTW, if the v3 interface is needed in future, will we extend the NativeBridgeCallbacks2, or define a new NatvieBridgeCallback3?

149:39-149:60
Wed May 06 19:16:40 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d39c1d0_11e18c4d
UUID: cd290587_5100366f
Bytes: 408
>> For fail initialization solution, how does houdini check the version of libnativebridge?

What exactly do you mean here?

>> For the impl of v2 interface, it's OK if you think current solution is better than all-in-one. BTW, if the v3 interface is needed in future, will we extend the NativeBridgeCallbacks2, or define a new NatvieBridgeCallback3?

We will extend to make sure we are backwards compatible.

149:39-149:60
Thu May 07 02:11:22 2015 +0000
Author: Jinghui Gu <1051763@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd290587_5100366f
UUID: 4d36f5df_18ff6d79
Bytes: 436
>>>> For fail initialization solution, how does houdini check the version of libnativebridge?
>> What exactly do you mean here?
Andreas mentioned "Houdini is still free to fail initialization to avoid this" in previous comments. I think it's good idea to give houdini a chance to determine whether supports current interface version of libnativebridge before initialization. But houdini cannot get the interface version in current code.

149:39-149:60
Thu May 07 02:24:57 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d36f5df_18ff6d79
UUID: 4d8435cc_78b3de4c
Bytes: 83
See the comments before: A second callback will be added to NativeBridgeCallbacks2.

149:39-149:60
Thu May 07 02:56:10 2015 +0000
Author: Jinghui Gu <1051763@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d8435cc_78b3de4c
UUID: 4d36f5df_b8b181c2
Bytes: 50
Got it. OK to me. Sorry for missing your comments.

149:39-149:60
Thu May 07 19:56:22 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d36f5df_b8b181c2
UUID: 4d8435cc_e1d0d2f7
Bytes: 168
Would you prefer a push method:

 NativeBridgeCallbacks2::setVersion

or a new initialize method:

 NativeBridgeCallbacks2::initialize2(..., uint32_t bridge_version)

?

151:0-163:52
Mon May 04 10:15:55 2015 +0000
Author: Eric Lin <1051588@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 706d52b3_7616cefc
Bytes: 76
So, for signals other than SIGSEGV, native bridge can still use sigaction()?

151:0-163:52
Mon May 04 15:03:33 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 706d52b3_7616cefc
UUID: f06142bc_74688120
Bytes: 196
The question is are there other important ones? If so, please describe a range that you think covers acceptable use cases.

I thought only SIGSEGV would be important. Everything else, not so much.

151:0-163:52
Tue May 05 02:36:11 2015 +0000
Author: Eric Lin <1051588@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f06142bc_74688120
UUID: 706d52b3_b9bdb7fb
Bytes: 446
I mean: Native bridge registers signal handler on behalf of apps code  native bridge is OK to use sigaction? 

A further discussion, how should native bridge decide which signal to use sigaction, and which one not? Can it assumes ART only call getSignalHandler(SIGSEGV), thus sigaction() all other signal handlers? (to prevent future ART changes from breaking it, native bridge can return NULL on getSignalHandler for signals other then SIGSEGV).

151:0-163:52
Tue May 05 03:30:41 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 706d52b3_b9bdb7fb
UUID: b0218a87_28396352
Bytes: 869
This is not intended to forbid the use of sigaction.

This API is for the cases when a native bridge would like the runtime to ensure that its handler is always first (after ART). If you are interested in other signals, and they don't have an ordering constraint like SIGSEGV, this isn't gonna force you to do it this way (libsigchain still accepts general sigaction...).

My original question was whether only SIGSEGV is enough. After talking with bdc, we'll likely remove the SIGSEGV restriction, and ART will just query the whole range supported by libsigchain (where this prioritization will be implemented). If you don't want it handled, simply return null for those signals and call sigaction yourself. Same goes for any additional handlers you want installed - just call sigaction normally, and they'll be in the normal chain.

Does this sound reasonable to you?

151:0-163:52
Tue May 05 05:30:24 2015 +0000
Author: Eric Lin <1051588@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b0218a87_28396352
UUID: 504a0e43_f90ac8a6
Bytes: 25
Yes, sounds good. thanks.

File: libnativebridge/native_bridge.cc

86:30-86:39
Wed May 06 04:15:31 2015 +0000
Author: Jinghui Gu <1051763@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d36f5df_12cd0c05
Bytes: 73
BTW, can we make this var as const to avoid modification?
Thanks, Jinghui

86:30-86:39
Wed May 06 04:18:03 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d36f5df_12cd0c05
UUID: 8d1e2d58_69c7ad49
Bytes: 52
I don't understand what you're trying to accomplish.

86:30-86:39
Wed May 06 04:21:55 2015 +0000
Author: Jinghui Gu <1051763@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d1e2d58_69c7ad49
UUID: 2d39c1d0_716c5888
Bytes: 90
I mean we can define it as below.
static const NativeBridgeCallbacks* callbacks = nullptr;

86:30-86:39
Wed May 06 05:06:47 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d39c1d0_716c5888
UUID: 6d19f971_dc0d5c3b
Bytes: 298
Sure. It necessitates a couple of signature changes, but is doable.

Obviously it's only for code cleanliness - anyone being able to look for a private data element and screw with it already has enough knowledge and control over the system. But we had enough discussions about perceived security...

141:41-141:42
Tue May 05 15:52:11 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 304d9a5a_372380d5
Bytes: 87
This is rather cryptic imo. How about comparing with a kMinSupported and kMaxSupported?

141:41-141:42
Tue May 05 15:59:27 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 304d9a5a_372380d5
UUID: 102df676_a381f1fe
Bytes: 646
My hope was to design something forward-compatible, so that it's easy to backport a bridge to older Android versions. So I didn't want kMaxSupported anymore. 1 is cryptic, agreed. It's just the minimal value (so 0 shows some failure).

As the bridge is working already, I feel we have all things that are needed for basic operation, so it should be fine. One thing that is probably missing is to report *our* version to the bridge (so that, e.g., a v3 bridge could either fail to initialize or adapt itself to being run as a v2).

Eric, could you weigh in here? Would another symbol in v2 bridges to communicate the libnativebridge version be OK?

141:41-141:42
Tue May 05 16:08:53 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 102df676_a381f1fe
UUID: 304d9a5a_5752c439
Bytes: 87
I'm good with not having using kMaxSupported but we should document the intention here.

141:41-141:42
Wed May 06 03:55:56 2015 +0000
Author: Jinghui Gu <1051763@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 102df676_a381f1fe
UUID: 4d36f5df_725578a6
Bytes: 219
Hi Andreas,
It's not necessary to keep forward-compatible for native bridge.
We need a clear interface for different version of native bridge.
If the version is not matched, then, libnativebridge should stop loading it.

495:30-495:31
Tue May 05 15:52:11 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 105416e3_d6d95472
Bytes: 93
nit: I'd prefer to use symbolic constants here and above even if it might look a bit useless.

495:30-495:31
Tue May 05 15:59:27 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 105416e3_d6d95472
UUID: b0218a87_0b04a1ce
Bytes: 7
Agreed.

495:30-495:31
Thu May 07 14:12:14 2015 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b0218a87_0b04a1ce
UUID: ad24d1ad_3313705b
Bytes: 59
callbacks->version >= NativeBridgeCallbacks2::kVersionNum ?

File: libnativebridge/tests/NativeBridgeVersion_test.cpp

2:17-2:21
Tue May 05 15:52:11 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 105416e3_56ee4404
Bytes: 4
2015

