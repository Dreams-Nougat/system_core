Revision: d172718fb8a8cad5e9a83a414436d0384b517dbf
Patch-set: 6
File: metricsd/uploader/bn_metricsd_impl.cc

42:0-54:1
Mon Dec 21 04:08:49 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2a3463db_86ebfe5e
Bytes: 56
All this could move up into main() and still make sense.

42:0-54:1
Mon Dec 21 18:10:05 2015 +0000
Author: Bertrand Simonnet <1076133@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2a3463db_86ebfe5e
UUID: 6a2adb7b_bdfdeb88
Bytes: 140
Parts of it could be moved (registering the binder interface) but the message_loop_ part should stay here IMO. It provides a nice isolation.

56:0-58:1
Mon Dec 21 04:08:49 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8a5c6f37_3626c6a5
Bytes: 92
And then you wouldn't need to wrap this with a method on the binder object, which feels odd.

56:0-58:1
Mon Dec 21 18:10:05 2015 +0000
Author: Bertrand Simonnet <1076133@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a5c6f37_3626c6a5
UUID: 4a2517a8_c7da229b
Bytes: 114
This is actually needed as we have two main loops and I didn't want to export |message_loops_| out of this object.

56:0-58:1
Tue Dec 22 16:33:40 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4a2517a8_c7da229b
UUID: ca33c71e_c1030255
Bytes: 182
You need to quit the second mainloop, but that could also be done by passing a pointer to the second mainloop (or a closure wrapping the BreakLoop() function) to your first mainloop.

File: metricsd/uploader/bn_metricsd_impl.h

59
Mon Dec 21 04:08:49 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6a53bb27_f53822ca
Bytes: 290
It's weird that a particular binder object also contains a reference to the global mainloop that will run all binder objects in this process.  Can I convince you to move the message loop up into the main() or at least up to the upload service if you want to make that the top level concept?

59
Mon Dec 21 18:10:05 2015 +0000
Author: Bertrand Simonnet <1076133@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a53bb27_f53822ca
UUID: ca62e7ed_dee301c0
Bytes: 387
Actually, this is not a global main loop but the main loop used for the binder thread only (to receive and handler metrics sample or "quit" event).
There is another main loop for the uploader part (aggregate the metrics, upload them, save them to disk, etc...).

We have two main loops to ensure we can receive lots of metrics samples even if we are doing IO work on the uploader thread.

59
Tue Dec 22 16:33:40 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ca62e7ed_dee301c0
UUID: aa3a13f4_a0cd1ae4
Bytes: 939
I realized that it was the loop handling just the Binder interface.  You could argue that since this main loop only drives this particular object, that it makes sense to keep it here.

However, my objection was more fundamental, that a binder object (even if it were the only binder object) should not hold a mainloop, since it is the mainloop that will drive all binder objects, and not the other way around.  My point was just that this leaves a marginally more confusing hierarchy for  the next person to add an interface to this service.

Suppose that later we want to register a callback binder with metricsd to receive notification of some interesting events.  That person has to reallize that those notifications happen on this message loop inside BnMetricsdImpl.  Dunno, maybe that's over engineering, but I thought it might be nice to see the threading structure of the program clearly laid out in the top level (main()) function.

59
Tue Dec 22 16:37:43 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa3a13f4_a0cd1ae4
UUID: ca33c71e_a1007e49
Bytes: 487
Actually, that's a more interesting example than I thought it would be, because you could theoretically call methods on the callback object from anywhere in your process without passing through the mainloop.  I'm unsure what happens when you call into the binder driver from a thread other than the one you'll be using for polling.  It seems safer to do this from that binder thread though, by passing the event to the binder message loop, and letting the callback happen on that thread.

59
Wed Dec 23 00:53:10 2015 +0000
Author: Bertrand Simonnet <1076133@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ca33c71e_a1007e49
UUID: 0af79f9a_4ead73bf
Bytes: 1637
Dig a bit more and initializing the binder main loop in main() actually looks pretty hard :/ It is also a miracle that this code works without me knowing all this:

* main loops do a lot during initialization, including registering to a static global map of thread -> mainloops.
Everything uses this map (binder_watcher, brillo's message loop, etc...).
Initializing two main loop in the same thread is dangerous because we need to carefully unregister/register the right main loop at the right time to get the correct result.

The fact that we actually have two static maps (one for brillo mainloop and one for the libchrome mainloop) tracking related object without coordination makes it scarier :/

* We can't get a closure to quit the (binder) main loop until the main loop is running. This makes initialization racy as we need to start the binder thread and wait to get a correct quit closure.

* debugging callback issues on a multi-threaded program is not fun, especially without all the DCHECKs. The service will just segfault without any message.


IMO, the cleanest approaches would be either:
1) keep the binder mainloop initialization in bn_metrics_impl but creating the instance and starting it (in a new thread) from main(). We would only pass a quit closure to UploadService.

2) create a "launcher" object (metricsd_service_runner ?), instanciated and owned by main(), that will create and own the binder mainloop. This allows us to keep BnMetricsImpl as close as possible to the interface while exposing the thread hierarchy cleanly.

Option 2 has my vote. It is more verbose but easier to understand.

What do you think?

