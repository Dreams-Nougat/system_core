Revision: b1f7c070ff21522384ce4d6e57c97e4a07ce3d0a
Patch-set: 1
File: /COMMIT_MSG

20:60-21:37
Wed Sep 30 02:56:01 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b5526a4f_d8f2cdcd
Bytes: 50
why you think the previous way may lose the error?

20:60-21:37
Wed Sep 30 03:55:51 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b5526a4f_d8f2cdcd
UUID: 75439281_1eb54db4
Bytes: 686
Good question. My theory is that the caller might be writing data until errno=EAGAIN. Then fdevent_process() detects an error and the handler is called with func(fd, FDE_ERROR|FDE_READ, arg). if the handler is written like "if (events & FDE_WRITE) { adb_write... }", then it won't do anything and it won't see the error.

My theory could be wrong if the OS always returns POLLOUT when returning POLLERR/POLLHUP/POLLINVAL (because then the handler would be called with FDE_WRITE|FDE_ERROR even without my change).

My theory could also be wrong if no adb code does what I described. I just checked and I don't think adb gets into this situation, so then this would only benefit new code.

20:60-21:37
Thu Oct 01 02:30:45 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 75439281_1eb54db4
UUID: 15a33681_d7918cd9
Bytes: 514
I think if some fd only wants to read or only wants to write, it will call synchronized read/write directly, instead of going through fdevent. If you read services.cpp, you can find many services running in a separate thread and do synchronized read/write.

I agree it is weird that why I get a FDE_READ when I only register for FDE_WRITE. Ideally I want to make all errors return FDE_ERROR. But I am not confident in making the change now. So I prefer to stay on using FDE_READ for error processing for stability.

20:60-21:37
Thu Oct 01 02:55:58 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 15a33681_d7918cd9
UUID: d55b5e6b_083fcf77
Bytes: 1679
Ok. Let me know how I should proceed with this review.

BTW, sysdeps_win32.cpp says in a comment 'fdevents emulation: this is a very simple implementation, we rely on the fact that ADB doesn't use FDE_ERROR'. I'm not really sure if the code is really relying on that.

But I do think that the sysdeps_win32 fdevents code is somewhat scary:

* Windows has select(), but because sysdeps has a custom socketpair implementation, select() won't work with it, so then WaitForMultipleObjects() + WSAEventSelect() was used instead.

* (Even without the custom socketpair implementation, select() probably wouldn't work anyway because it is limited to 64 sockets on Windows. But WaitForSingleObjects() is also limited to 64 so sysdeps has a gross hack to make it work beyond 64.)

* WSAEventSelect() requires that after an event occurs, that a 're-enabling' function (like recv/send) be called, and if it isn't called, you won't get future events for a socket. Is this requirement satisfied by adb code? Perhaps, but I'm not sure (maybe I will try to write a test case for this). The worst case scenario is hangs I guess.

* Windows Vista has WSAPoll(), but from reading the web, it sounds buggy and not often used.

Basically, Windows has a different I/O model than Unix. Windows really wants to use an I/O completion port with I/Os posted ahead of time instead of waiting for readiness. But that design is all about performance and I don't think Windows adb is having any performance issues (seems like reliability is the #1 issue hence why I'm looking at this sysdeps code).

Anyway, I just wanted to give you a sense of what the Windows side has to deal with to keep fdevents working.

File: adb/fdevent.cpp

177:8-177:30
Wed Sep 30 02:56:01 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 953c86f3_1fa1c395
Bytes: 38
good detective. I think you are right.

238:12-239:36
Wed Sep 30 02:56:01 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 15a33681_836bdef7
Bytes: 46
Do you have any reason to change the strategy?

238:12-239:36
Wed Sep 30 03:55:51 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 15a33681_836bdef7
UUID: b5398a03_e068c2fc
Bytes: 100
No, this is only theoretical and might actually be impossible (as I described in the other comment).

