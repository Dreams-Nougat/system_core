Revision: f6ecf11258185671e0e0189104629000d114ca2b
Patch-set: 2
File: include/nativebridge/native_bridge.h

231:9-231:24
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3d8cca86_d6803412
Bytes: 420
Why use this instead of the legacy one? I remembered you want use it to verify if a library is accessible in one namespace once, is it?

The legacy one is just to verify Machine type of a .so. If the .so should be loaded by native bridge (arm library on x86 devices for example), the needs_native_bridge will be set, and native bridge is responsible for this library instead of dynamic linker. I think we should keep it.

231:9-231:24
Thu Jul 07 16:19:50 2016 +0000
Author: Dimitry Ivanov <1041673@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3d8cca86_d6803412
UUID: fd26b29b_86c16af6
Bytes: 349
one way to implement this is to scan directories and see of .so files have supported Machine type.

The difference between this and the old one is this should be determined for application before any of the actual loading starts. Also old one uses path to .so file - this one should be able to accept list of directories (native library search path)

File: libnativeloader/native_loader.cpp

149:25-149:48
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bdc43ad3_24dd32eb
Bytes: 82
NativeBridge cannot determinate whether itself should start on a app library path.

149:25-149:48
Thu Jul 07 16:19:50 2016 +0000
Author: Dimitry Ivanov <1041673@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bdc43ad3_24dd32eb
UUID: fd26b29b_c6bb6284
Bytes: 49
see above for one proposed way to implement this.

152:26-152:42
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bdc43ad3_64fe0a3b
Bytes: 764
By this design, a namespace uses NativeBridge or not?
I understand you want the library of an application is pure one ABI. We are the same.

But, Android is so diverse, there are many apps packed x86 & arm library together and declare itself as an x86 app. And there are other apps dynamically download x86 library but declare itself as a ARM app.
By this new "IsSupport/namespace" design, these apps cannot be compatible with Intel devices. Maybe we can follow the original design "check if nativebridge is needed library by library?"

And, can we bridge the namespace of nativebridge and linker? We really need a way to handle the cases talked above.
We hate these apps much more than you guys, trust me. but we cannot persuade them to develop decent apps.... :(

152:26-152:42
Thu Jul 07 16:19:50 2016 +0000
Author: Dimitry Ivanov <1041673@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bdc43ad3_64fe0a3b
UUID: fd26b29b_a643c652
Bytes: 156
It looks like an accident to me... I do not think these apps are doing it on purpose.

Also can you send me names of apps doing this (the more than better)?

302:9-302:25
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bdc43ad3_44494ea5
Bytes: 1038
I think NativeBridgeInitNamespace should always be called.

As far as I understand, InitPublicNamespace() can be called when:
1. app is just started, dex loaded by Android, and ApplicationLoader calls into NativeLoader.
2. app uses DexClassLoader, the classloader namespace is not created since the loading of this dex is not by ApplicationLoader. In this dex java code, app System.loadLibrary() and finally call into NativeLoader, and  namespace for new dex's classloader has not been created, so create classloader in OpenNativeLibrary().

For the first one, the path is library path of app. NativeBridge cannot determine whether the app needs it in app startup stage.
For the second one(we won't expect it here right?), the path is a library path, seems ok.

I think that, InitNamespaces is just like let NativeBridge turn into a mode such that it could well handle library loading. I suggest let namespace of NativeBridge always init. This only actually happens on Intel devices which really equipped with nativebridge implementation.

454:19-454:26
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bdc43ad3_a4ef628c
Bytes: 34
Is it NativeBridgeGetError() here?

454:19-454:26
Thu Jul 07 16:19:50 2016 +0000
Author: Dimitry Ivanov <1041673@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bdc43ad3_a4ef628c
UUID: fd26b29b_0633ba03
Bytes: 13
right - done.

477:5-477:23
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bdc43ad3_849fc61d
Bytes: 113
NativeBridge v3 has NativeBridgeUnloadLibrary() now. NativeLoader can call it to unload a library when necessary.

477:5-477:23
Thu Jul 07 16:19:50 2016 +0000
Author: Dimitry Ivanov <1041673@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bdc43ad3_849fc61d
UUID: fd26b29b_2630b6f4
Bytes: 33
it is currently done by art code.

