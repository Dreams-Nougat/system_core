Revision: 654a41b4fbff21b8d7dfc72a08de05014670fdac
Patch-set: 5
File: include/netd_client/NetdClient.h

21
Tue May 20 10:59:55 2014 +0000
Author: Paul Jensen <1016583@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aa1c9852_a03803ea
Bytes: 26
Not in alphabetical order.

21
Wed May 21 18:29:10 2014 +0000
Author: Sreeram Ramachandran <1031429@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa1c9852_a03803ea
UUID: ff281483_446aa7f7
Bytes: 4
Done

File: libnetd_client/NetdClient.cpp

93
Tue May 20 10:59:55 2014 +0000
Author: Paul Jensen <1016583@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3f3f0cb7_5046ece0
Bytes: 78
You only took half of my recommendation.  You need ANDROID_MEMBAR_FULL() here.

93
Wed May 21 14:17:11 2014 +0000
Author: Sreeram Ramachandran <1031429@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3f3f0cb7_5046ece0
UUID: 3f58ec40_ce2d9785
Bytes: 2126
I don't see the need for a memory barrier here.

As far as I understand, a memory barrier ensures that the compiler/CPU will not reorder loads/stores across it. Within this context, there are no other independent global loads/stores anyway.

Perhaps your concern is that you want other threads/CPUs to see the effects of the change immediately? I.e., maybe there's a chance that the store will remain in the local CPU's store-buffer indefinitely and never make it to the caches / main memory?

First, if another CPU tries to read the variable, cache coherency guarantees that it will see the correct value. There's no chance that it will use an older value.

Second, a memory barrier doesn't guarantee that the store-buffer is flushed anyway. References:
http://www.freebsd.org/doc/en/books/arch-handbook/smp-lock-fundamentals.html: "a memory barrier does not force the contents of a CPU's local cache or store buffer to flush"
http://www.rdrop.com/~paulmck/scalability/paper/whymb.2009.04.05a.pdf: " it could use the store buﬀer to hold subsequent stores until all of the prior entries in the store buﬀer had been applied."

Or perhaps your concern is that there is some other store operation in the caller's context which should be guaranteed to occur after the operation here? So, something like this:

    // thread 1
    setNetworkForProcess(...);
    flag = 1;

    // thread 2
    if (flag) {
        // depend on netIdForProcess being up-to-date

So, without a memory barrier, it's possible that the flag gets updated first, before netIdForProcess. But this argument doesn't hold water, because:
1. We have no obligation to imagine that this is possible and support it. Otherwise, this reduces to saying that any library function that performs any global store must immediately then apply a memory barrier. And conversely, that if it reads any global store, it must first apply a barrier prior to the load.
2. The caller needs to synchronize access to the flag anyway. So, they are going to need a store-release in thread 1, and an acquire-load in thread 2. So, that provides the necessary barrier/synchronization.

93
Wed May 21 19:33:02 2014 +0000
Author: Paul Jensen <1016583@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3f58ec40_ce2d9785
UUID: 7f3504d1_fc513691
Bytes: 2055
I'm fine without the memory-barrier.  I agree with much of your logic.  I still feel a memory barrier would make this function more correct if one assumes it's definition to be that once the function has returned its affect is in place.   Assuming the awesome cache coherency of modern processors I feel people assume when a function completes that it's effect is heard on all cores.  Without the memory-barrier the divergence from strict adherence to this definition is minimal, so I'm fine with continuing without the memory barrier.

Let me explain with a little example of where a memory barrier would make things more correct given these definitions:

Two networks connect almost simultaneously.  Two threads call setNetworkForBlah() almost simultaneously to begin using these new networks.  After calling setNetworkForBlah() these two threads immediately read some hardware clock using a load instruction.  These two threads write to a log something along the lines of "started using network X at time Y".  Later analysis of the log assumes that things happening at later times overrule older events, so we might attribute all traffic to the last network selected.  The problem is without strict ordering of loads and stores the load of the timer may be swapped with the store to the netId, in which case we might attribute all traffic to the wrong network.

Anyhow, yes, my test case is contrived and someone would be silly to not use locking or some other more proper synchronization, but a memory barrier is a simple way to not necessarily enforce that by the time the function has returned that the change has taken place, but to enforce that the by the perceivable time (i.e. reading from a clock) the functions has returned that the change has taken place.

Another way to look at this is:  If the netId were a larger struct such that it couldn't fit in sig_atomic_t, some locking would have to be used to access it, in which case the release of the lock would guarantee the ordering that a memory barrier would provide in this implementation.

93
Wed May 21 20:05:19 2014 +0000
Author: Sreeram Ramachandran <1031429@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f3504d1_fc513691
UUID: 7f8344c5_16b14ce4
Bytes: 365
Thanks for the detailed response. As we discussed and agreed offline, we'll go without the barrier for now.

Re: the point in your last paragraph, I agree. I've added a TODO to convert "volatile sig_atomic_t" to std::atomic<>. Conveniently, std::atomic<> works for any POD type, and not just primitive types, so that's definitely the right way to go for the future.

106
Tue May 20 10:59:55 2014 +0000
Author: Paul Jensen <1016583@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aa1c9852_803b07e6
Bytes: 6
Ditto.

106
Wed May 21 18:29:10 2014 +0000
Author: Sreeram Ramachandran <1031429@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa1c9852_803b07e6
UUID: bf4bfc72_84bd46f2
Bytes: 8
ditto :)

137:4-138:44
Tue May 20 10:59:55 2014 +0000
Author: Paul Jensen <1016583@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3f3f0cb7_b05e38a0
Bytes: 203
How come we don't have legitimate types for this?  Like:
typedef struct {
  uint8_t command;
} NetdCommandHeader;
typedef struct {
  NetdCommandHeader header;
  unsigned netId;
} NetdNetForSocketCommand;

137:4-138:44
Wed May 21 18:29:10 2014 +0000
Author: Sreeram Ramachandran <1031429@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3f3f0cb7_b05e38a0
UUID: bf4bfc72_04803637
Bytes: 299
Done. To avoid proliferation of data types for each command, I've coalesced the types into a single command, with a note that the netId argument is ignored for all but one. This also makes it easy on the receiving side to receive data of that type directly, instead of going through a char[] buffer.

