Revision: 3ce8d8de3b36ce81930207e115424025c9a71a16
Patch-set: 1
File: init/builtins.cpp

631:55-631:66
Thu Jan 07 23:28:17 2016 +0000
Author: Bertrand Simonnet <1076133@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aa1773d7_7504bf5d
Bytes: 317
Using this flag to detect if |s| is the console service is a bit weird: This flag actually means "console required" but seems to only be used by console.

Should we create a new service attribute (unterminable ? ignores_sigterm?) set for services that ignore the SIGTERM signal so that we don't have to wait for them?

642:19-642:24
Thu Jan 07 23:40:01 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2a52a3ad_b2ac9daa
Bytes: 76
Maybe make this a constant? kTerminateServiceDelayMicroSeconds or something.

642:19-642:24
Fri Jan 08 00:48:11 2016 +0000
Author: Bertrand Simonnet <1076133@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2a52a3ad_b2ac9daa
UUID: 0a4ddf0f_7317fb31
Bytes: 4
Done

File: init/service.cpp

817:8-817:27
Thu Jan 07 23:40:01 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2a52a3ad_52fe7984
Bytes: 14
Can this fail?

817:8-817:27
Fri Jan 08 00:42:15 2016 +0000
Author: Bertrand Simonnet <1076133@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2a52a3ad_52fe7984
UUID: ea1debf7_4bfeba84
Bytes: 122
I don't think it can. This not accessed concurrently and RemoveService can handle |svc| not being in the list of services.

824:0-825:5
Thu Jan 07 23:40:01 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0a4ddf0f_38ccf0b8
Bytes: 344
Should this have a way of erroring out in case ReapOneProcess constantly returns true?

I guess you're calling waitpid with WNOHANG and returning false in that case, you cannot always get and kill a process and never end... unless the system is in the middle of something like a fork bomb? I guess maybe in that case we don't care what happens.

824:0-825:5
Fri Jan 08 00:42:15 2016 +0000
Author: Bertrand Simonnet <1076133@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a4ddf0f_38ccf0b8
UUID: aa1773d7_b5e6d762
Bytes: 427
There might be pathological cases where this will run forever but I don't think there is a good way to handle it. We could set a limit on the number of process we can Reap in one go (1000?) but I'm not sure what the consequences would be in the rest of the system. In doubt, it might be better to keep this simple.

A service crash loop will not cause this as we will first reap all stopped services before starting them again.

824:0-825:5
Fri Jan 08 00:49:27 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa1773d7_b5e6d762
UUID: 2a52a3ad_52b2f94f
Bytes: 154
Hmmm... I wonder if this is going to cause a problem if a third party process tries spinning up lots of processes, and prevents the user from rebooting...

824:0-825:5
Fri Jan 08 01:26:06 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2a52a3ad_52b2f94f
UUID: aa1773d7_95d87375
Bytes: 247
Given that the status quo is killing everything with SIGKILL, a solution that only calls waitpid kNotSoBigNumber times and then does SIGKILL still seems like a marked improvement to the current state, and doesn't include a seemingly infinite loop.

824:0-825:5
Fri Jan 08 17:40:24 2016 +0000
Author: Bertrand Simonnet <1076133@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa1773d7_95d87375
UUID: 6a901bcb_5e5d7571
Bytes: 678
IIUC, the pathological case already exist in init:
* a rogue process spins lots of child process that exit (creating an infinity of process to wait for).
* the SIGCHLD signal is received by init.
* at the next iteration of the main loop, epoll_wait selects ReapAnyOutstandingChildren and will run forever (if we can generate an infinity of child process exiting).
* As ReapAnyOutstandingChildren never exits, the main loop never processes any other event and cannot handle the reboot request (sent with a system property).

Limiting the number of time we can call ReapOneProcess in ReapAnyOutstandingChildren sounds like a good idea. Any opinion on a good number? 10? 100? 1000?

824:0-825:5
Fri Jan 08 18:06:53 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a901bcb_5e5d7571
UUID: 6a79fb72_765fb052
Bytes: 126
I defer to init owners on this (Elliot, feel free to comment) but capping at 1000 continuous failed ReapOneProcess calls SGTM.

File: init/service.h

184:35-184:42
Thu Jan 07 23:40:01 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4a4357e2_1f1d5ef7
Bytes: 21
Nit: "was cleaned up"

184:35-184:42
Fri Jan 08 00:48:11 2016 +0000
Author: Bertrand Simonnet <1076133@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4a4357e2_1f1d5ef7
UUID: 8a1aaf01_b609017b
Bytes: 4
Done

