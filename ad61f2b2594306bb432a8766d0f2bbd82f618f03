Revision: ad61f2b2594306bb432a8766d0f2bbd82f618f03
Patch-set: 2
File: init/capabilities.cpp

89:45-89:70
Fri Dec 16 03:18:04 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_b7e6a2cd
Bytes: 226
Is this needed anymore? Service::ParseCapabilities errors out if last_valid_cap >= to_keep.size(), so this is an impossible to occur condition without "cap < to_keep.size()" also triggering.

(same comment on line 109 and 137)

89:45-89:70
Fri Dec 16 03:49:12 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fa6fafa9_b7e6a2cd
UUID: 1af2c318_6310b6ff
Bytes: 173
That's a good point. You could argue that this code should be resilient even if the caller has not checked what the max runtime supported cap is, but I think KISS wins here.

148
Fri Dec 16 03:33:54 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_5771cef6
Bytes: 150
Here you return an int, but below you return an unsigned long. I suspect you should return an unsigned long here too. At a minimum, it's inconsistent.

148
Fri Dec 16 03:49:12 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fa6fafa9_5771cef6
UUID: 1af2c318_8313420c
Bytes: 278
Maybe it makes sense to make them all unsigned ints. unsigned int -> unsigned long promotion is defined and doesn't do anything unexpected. The int args would get promoted to long when passed to prctl. With 40 capabilities, unsigned int is clearly big enough. What do you think?

File: init/service.cpp

320:0-323:5
Fri Dec 16 03:18:04 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_d7723e50
Bytes: 513
This is stricter than necessary. If anyone ever upgrades the kernel, for instance, without upgrading this file / the libc header files, init will fail to start services, which will make bringup slightly harder.

Instead, perhaps it makes more sense to only error out if the config file requests a capability not supported by the kernel. How about, around line 327, something like:

  int cap = LookupCap(arg);
  if ((cap == -1) || (cap > GetLastValidCap())) {
    *err = StringPrintf("...");
    return false;
  }

320:0-323:5
Fri Dec 16 03:49:12 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fa6fafa9_d7723e50
UUID: 1af2c318_c3db8a3a
Bytes: 167
That's reasonable. I'm not sure how often we update actual kernels beyond kernel headers, but no need to be overly strict when it doesn't provide a security guarantee.

320:0-323:5
Fri Dec 16 03:59:08 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1af2c318_c3db8a3a
UUID: 1af2c318_43f01aae
Bytes: 478
Actually, thinking more about this, if the kernel gets updated but the headers don't, then LookupCap will return -1 -- LookupCap looks at the kernel headers. So there's really no way to identify the case where the user is requesting a capability not present in the current headers vs a capability that doesn't exist at all in the upstream headers.

So what I'm gonna do is warn but not error (i.e. not return false) if we find the runtime has more capabilities than the headers.

327:8-327:11
Fri Dec 16 03:33:54 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_d7931ee7
Bytes: 49
int vs unsigned long for capability integer type.

327:8-327:11
Fri Dec 16 04:08:47 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fa6fafa9_d7931ee7
UUID: 1af2c318_a3cbde63
Bytes: 74
True. I'll change the check below to < 0 and convert using explicit casts.

