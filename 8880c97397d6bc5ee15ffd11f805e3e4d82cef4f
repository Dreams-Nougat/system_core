Revision: 8880c97397d6bc5ee15ffd11f805e3e4d82cef4f
Patch-set: 1
File: adf/libadfhwc/adfhwc.cpp

217
Thu Sep 22 23:22:23 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d06f23aa_3a52792f
Bytes: 67
since this is C++ you can just say

  struct sigaction action = {};

217
Fri Sep 23 17:43:12 2016 +0000
Author: Marissa Wall <1073546@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_3a52792f
UUID: d06f23aa_ee276375
Bytes: 4
Done

220
Thu Sep 22 23:22:23 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d06f23aa_fa3801f5
Bytes: 132
you can also use a lambda here if you don't want the handle_thread_exit function.

    sa.sa_handler = [](int) { pthread_exit(0); };

220
Fri Sep 23 17:43:12 2016 +0000
Author: Marissa Wall <1073546@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_fa3801f5
UUID: d06f23aa_0e2d7f54
Bytes: 4
Done

220
Fri Sep 23 19:33:17 2016 +0000
Author: Greg Hackmann <1015340@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_0e2d7f54
UUID: d06f23aa_3be358cb
Bytes: 334
What are the semantics of pthread_exit()?  fds[] is allocated on the heap and needs to be cleaned up.

If pthread_exit() unwinds the stack, then we just need to change fds[] from a C-style array to a std::vector and let its destructor handle everything.

(Also, nitpick: use nullptr instead of 0 since pthread_exit() returns a void *)

220
Fri Sep 23 19:45:58 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_3be358cb
UUID: d06f23aa_fb9720ef
Bytes: 267
annoyingly, we have an open bug on that: http://b/27860783

(yes, we should unwind, but, no, we don't.)

you can probably just get away with a VLA in the meantime, as long as you're not worried about intf_fds.size()*sizeof(pollfd) being a significant amount of stack.

220
Fri Sep 23 19:51:07 2016 +0000
Author: Greg Hackmann <1015340@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_fb9720ef
UUID: d06f23aa_1bb69c90
Bytes: 187
intf_fds.size() == # of displays, so it shouldn't be too large in practice.

But at the time I wrote this, gcc followed ISO C++ and forbade VLAs in C++ mode ... does clang allow this now?

220
Fri Sep 23 19:52:40 2016 +0000
Author: Greg Hackmann <1015340@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_1bb69c90
UUID: d06f23aa_db45046d
Bytes: 147
(Realizing it would just be easier to try it myself ...)

For the record, yes, clang lets you use VLAs in C++ mode.  That seems like the way to go.

222
Thu Sep 22 23:22:23 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d06f23aa_3a1b598b
Bytes: 93
-1 is the only failure return, and you don't need the local.

  if (sigaction(...) == -1) ...

222
Fri Sep 23 17:43:12 2016 +0000
Author: Marissa Wall <1073546@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_3a1b598b
UUID: d06f23aa_2e123b10
Bytes: 4
Done

241:11-242:22
Thu Sep 22 23:22:23 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d06f23aa_ba176959
Bytes: 68
TEMP_FAILURE_RETRY around the call to poll would let you remove this

241:11-242:22
Fri Sep 23 17:43:12 2016 +0000
Author: Marissa Wall <1073546@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_ba176959
UUID: d06f23aa_5d072f77
Bytes: 261
Thanks for reviewing the code!

It looks like this section is doing "while (err == -1 && errno != EINTR)" and TEMP_FAILURE_RETRY does "while (err == -1 && errno == EINTR)". This code might have been written wrong originally. TEMP_FAILURE_RETRY makes more sense.

241:11-242:22
Fri Sep 23 19:14:22 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_5d072f77
UUID: d06f23aa_e9cafd69
Bytes: 130
oh wow, i didn't notice that! presumably they meant `continue`, but ghackmann will know. (worth a comment if this was deliberate!)

241:11-242:22
Fri Sep 23 19:33:17 2016 +0000
Author: Greg Hackmann <1015340@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_e9cafd69
UUID: d06f23aa_fb96403c
Bytes: 166
The intent was that pthread_kill() from the parent thread would interrupt poll().  Which doesn't actually work as intended, since there's no signal handler installed.

302
Thu Sep 22 23:22:23 2016 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d06f23aa_9a038d19
Bytes: 56
this code never runs in a VM, right? (ART uses SIGUSR1.)

302
Fri Sep 23 17:43:12 2016 +0000
Author: Marissa Wall <1073546@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06f23aa_9a038d19
UUID: d06f23aa_4e0f77e7
Bytes: 4
Done

