Revision: 33ff1698960a03d3385528dada9213b33dc07d85
Patch-set: 2
File: adb/fdevent.cpp

51:20-51:32
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 64cf5e9f_aa0413db
Bytes: 159
Make this static? I'm guessing you didn't kill the prev/next fields of fdevent because fdevent.h is also used by sysdeps_win32.cpp which still uses the fields?

51:20-51:32
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64cf5e9f_aa0413db
UUID: 04c1426c_fae9be2a
Bytes: 55
done. yes, I think we can leave that for later changes.

65:19-65:31
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 244c8613_612bb218
Bytes: 21
overload operator<< ?

65:19-65:31
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 244c8613_612bb218
UUID: e4c34e74_b898f0b2
Bytes: 4
Done

67:8-67:17
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4c34e74_0868af2d
Bytes: 146
What is fde.events for if fde.state already contains FDE_READ/WRITE/ERROR? Maybe there is some potential cleanup between fde.state and fde.events?

67:8-67:17
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4c34e74_0868af2d
UUID: 84d4522f_31df57cf
Bytes: 166
fde.state shows what the user wants in FDE_READ/WRITE/ERROR, fde.events shows the real events happened. They have different function. Am I misunderstanding your idea?

67:8-67:17
Fri Sep 11 05:57:25 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 84d4522f_31df57cf
UUID: 244c8613_647c1bf6
Bytes: 145
Ah, ok, makes sense. I guess my follow-up question then is: why doesn't this print out fde.events? But that might not be important, I don't know.

67:8-67:17
Tue Sep 15 01:01:15 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 244c8613_647c1bf6
UUID: 44725a92_b4ae95b9
Bytes: 278
AFAIK, fde.events is not as useful as fde.state. fde.events is only valid when fde is on the pending_list. And fde is dumped mostly when there is some change to the fde, fde.state is more relevant. Of course we can print fde.events as well, but I also think it is not important.

105:23-105:30
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4ef2afe_1298c837
Bytes: 16
nit: destroying?

105:23-105:30
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c4ef2afe_1298c837
UUID: 44cedaa4_be2216e2
Bytes: 4
Done

119:4-119:9
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4ef2afe_32698cc0
Bytes: 65
error check? that will conveniently check the validity of the fd.

119:4-119:9
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c4ef2afe_32698cc0
UUID: 24c9e69c_3553c37b
Bytes: 204
done. unit test added. Although it is easy to check the error, we'd better leave it for poll() to handle it properly. For here, we may just report the error. Ignoring the error or abort() seem not proper.

120:18-120:48
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 04c1426c_cfa2bd9c
Bytes: 165
I thought the point of using emplace() was to avoid unnecessary object construction/copying? Then don't you want to use emplace(fde->fd, fde)? Or do I misunderstand?

120:18-120:48
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 04c1426c_cfa2bd9c
UUID: 64cf5e9f_26595600
Bytes: 198
Here is not performance critical, I just wrote for convenience. emplace(fde->fd, fde) seems a little confusing as PollNode doesn't appear in it. By the way, I find it is suitable for error checking.

121:4-121:14
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 84d4522f_4570d461
Bytes: 215
I think that LOG() from logging.h does not contain an 'if', so it will always run dump_fdevent() even if logging is not enabled. logging.h should probably be fixed (adding the if might fix the errno issue as well?).

121:4-121:14
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 84d4522f_4570d461
UUID: 44fdfae7_e50a0c98
Bytes: 554
Yes, this is a problem. logging.h has a default log level INFO, and the level can be adjusted by env ANDROID_LOG_TAGS. But there is no way to set environment for adbd. I think one solution is to set the log level according to trace setting. I prefer to do this in a separate CL. 
for the errno problem, I don't have any good idea to save errno in any situation while keeping current convenient logging style (I mean LOG() << xxx). But I am optimistic that we rarely meet the situation that errno should be saved while xxx in "LOG() << xxx" changes errno.

121:4-121:14
Fri Sep 11 05:57:25 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44fdfae7_e50a0c98
UUID: e4c34e74_5b69ce03
Bytes: 542
adb.cpp shows that there is a property persist.adb.trace_mask but that is for ADB_TRACE-style flags, not ANDROID_LOG_TAGS-style. Yeah, separate CL is fine.

Before I attempted the LOG() errno-saving, I looked for instances of code that depended on errno being preserved and there seemed to be at least a couple. (Of course, the good news is that most of the time errno is not overwritten.) I'll try to investigate this LOG()/errno issue next week (since I made the original errno restoring change), or you guys can feel free to beat me to it.

132:22-132:29
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 24c9e69c_cdcf6d90
Bytes: 28
set fde->fd=-1 just in case?

132:22-132:29
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 24c9e69c_cdcf6d90
UUID: a4bdd6e7_b47eb977
Bytes: 4
Done

195:8-195:17
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4ecf63c_45765e61
Bytes: 29
android::base::StringAppendF?

195:8-195:17
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4ecf63c_45765e61
UUID: c4ef2afe_ae017b7b
Bytes: 4
Done

206:4-206:8
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4ecf63c_a5cdaaf3
Bytes: 90
why PLOG instead of LOG? I don't see any syscall that might set errno. Copy & paste error?

206:4-206:8
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4ecf63c_a5cdaaf3
UUID: c4ef2afe_8efc77e0
Bytes: 124
yeah, a copy & paste error. Firstly there was only one log below poll(), then I wanted to add another one to dump_pollfds().

207:8-207:11
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 04c1426c_8fc3a572
Bytes: 30
check for error? handle EINTR?

207:8-207:11
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 04c1426c_8fc3a572
UUID: a4bdd6e7_947bb588
Bytes: 4
Done

218:12-218:31
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 84d4522f_901aac38
Bytes: 104
so if I didn't request FDE_ERROR, I can still be called back for it? I guess things are better that way.

218:12-218:31
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 84d4522f_901aac38
UUID: a4bdd6e7_7478218b
Bytes: 168
I behave like this just because it is poll()'s behavior (unlike select()). But I think it doesn't matter, because now adb doesn't have any idea how to handle FDE_ERROR.

218:12-218:31
Fri Sep 11 05:57:25 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4bdd6e7_7478218b
UUID: 64cf5e9f_06bd3a0e
Bytes: 17
What do you mean?

218:12-218:31
Tue Sep 15 01:01:15 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64cf5e9f_06bd3a0e
UUID: e467cecb_4dc4d998
Bytes: 165
for FDE_ERROR, adb only print a debug message. The real error is handled when processing FDE_READ. So I think it doesn't matter to have FDE_ERROR or not in practice.

221:31-222:41
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 04c1426c_6ff85184
Bytes: 100
So this assumes that the caller will do a read? What if it only does a write? Or is that impossible?

221:31-222:41
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 04c1426c_6ff85184
UUID: 64cf5e9f_266716af
Bytes: 82
only two places use FDE_WRITE, and their callbacks all have handling for FDE_READ.

221:31-222:41
Fri Sep 11 05:57:25 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64cf5e9f_266716af
UUID: 244c8613_246db33d
Bytes: 2
ok

232:12-232:34
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 44cedaa4_48990ffa
Bytes: 103
can one be inserted twice onto the list? Is that ok? Is the pending bit preserved ok in that situation?

232:12-232:34
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44cedaa4_48990ffa
UUID: 44fdfae7_85d1885c
Bytes: 122
strictly it is possible. But only when fdevent_install() the same fdevent for different fds. check is added here for that.

232:12-232:34
Fri Sep 11 05:57:25 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44fdfae7_85d1885c
UUID: 44cedaa4_5e05421a
Bytes: 116
I don't think I understand how the CHECK_EQ(fde->fd, pollfd.fd) check checks whether the fde is already in the list?

232:12-232:34
Tue Sep 15 01:01:15 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44cedaa4_5e05421a
UUID: 0465c2c3_4f94cd02
Bytes: 389
suppose we have two fdevent_install() with the same fde but different fd.
fdevent_install(&fde, 1);
fdevent_install(&fde, 2);

fde.fd = 2
when some events happens on fd 1, it can be checked that fde.fd (2) != pollfd.fd (1).

I know this check is less clear than having a HashSet for used fdevents. But I think this error is unlikely to happen, and we don't need to spend much effort on it.

232:12-232:34
Tue Sep 15 02:09:30 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0465c2c3_4f94cd02
UUID: e467cecb_68c7cbcc
Bytes: 181
I was thinking of a different scenario: one fd, one fde. POLLOUT occurs, so fde gets added to pending_list. POLLIN occurs, so fde gets added to pending_list again. Or am I mistaken?

232:12-232:34
Tue Sep 15 02:44:41 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e467cecb_68c7cbcc
UUID: a9420f4a_3e5a151b
Bytes: 100
if POLLIN occurs in the first poll() call, it must be processed before doing the second poll() call.

254:10-254:12
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4c34e74_135464c6
Bytes: 34
GE? I guess really doesn't matter?

254:10-254:12
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4c34e74_135464c6
UUID: 84d4522f_11b57b4e
Bytes: 4
Done

302:8-302:19
Wed Sep 09 23:48:56 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4bdd6e7_d1eee430
Bytes: 287
My understanding is that LOG(FATAL) calls abort() and that can make a coredump. I'm not sure if that makes sense for 'expected' runtime error conditions. In practice, I don't think it comes up because this stuff probably never fails (it isn't like adb is perfect with all memory allocs).

302:8-302:19
Fri Sep 11 04:38:23 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4bdd6e7_d1eee430
UUID: 64cf5e9f_26cef6ee
Bytes: 175
Yes, LOG(FATAL) causes abort(). I think failure is not acceptable here. I guess if here fails, the connection will never stop when you try to run commands like "adb shell ls".

302:8-302:19
Fri Sep 11 05:57:25 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64cf5e9f_26cef6ee
UUID: 44fdfae7_10b93403
Bytes: 195
Yes, failure is not acceptable, but do you really want a coredump (due to abort())? I don't know, I don't have a quick solution here, so maybe this is just something to think about in the future.

302:8-302:19
Tue Sep 15 01:01:15 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44fdfae7_10b93403
UUID: 848ff2ac_8da50de9
Bytes: 53
I think it doesn't matter. I don't worry about space.

