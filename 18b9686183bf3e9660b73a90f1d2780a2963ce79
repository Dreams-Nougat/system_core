Revision: 18b9686183bf3e9660b73a90f1d2780a2963ce79
Patch-set: 2
File: adb/adb.c

1445
Thu Mar 21 20:49:20 2013 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: SNowJx3Q
Bytes: 39
space after "if" and space after comma.

1445
Thu Mar 21 21:19:11 2013 +0000
Author: David Turner <1000411@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: SNowJx3Q
UUID: ST7M42Ks
Bytes: 70
that's not my code, I'm just cut-and-pasting here, but I'll fix it :-)

1450
Thu Mar 21 20:49:20 2013 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: SNqwGA2A
Bytes: 26
check malloc return value?

1450
Thu Mar 21 21:19:11 2013 +0000
Author: David Turner <1000411@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: SNqwGA2A
UUID: ST9M-VI8
Bytes: 37
I'll add that (again, original code).

1467
Thu Mar 21 20:49:20 2013 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: SNmysmzQ
Bytes: 138
The adb host will write OKAY twice? Is this intentional?

Like you did on line 1523, can you add a similar comment if this is intentional.

1467
Thu Mar 21 21:19:11 2013 +0000
Author: David Turner <1000411@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: SNmysmzQ
UUID: STzNMyFA
Bytes: 176
the original code was writing "OKAYOKAY" on the host, so I've tried to keep it the same. However, I'm not convinced that this was necessary in any way. I'll test it to be sure.

1471
Thu Mar 21 20:49:20 2013 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: SNgyxV4c
Bytes: 31
space after if (here and below)

1477
Thu Mar 21 20:49:20 2013 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: SNiy2k4A
Bytes: 18
space after commas

1517
Thu Mar 21 21:09:00 2013 +0000
Author: Kenny Root <1002975@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: SNixSE0A
Bytes: 102
I don't think this binds to a transport, so any device can connect to the now opened port on the host.

1517
Thu Mar 21 22:26:11 2013 +0000
Author: David Turner <1000411@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: SNixSE0A
UUID: STzMeiCA
Bytes: 760
I'm not sure I understand what you're referring to. Can you clarify?

there is an acquire_one_transport() call just above. When running on the device, ttype will be kTransportAny, and serial will be NULL. The acquire_one_transport() above will return the single active transport that adbd knows about (it fails if there is no transport, i.e. the device is not connected through USB or has USB debugging disabled, or even if there are more than one transport, which I don't think would happen on the device).

We could add support for kTransportHost on acquire_one_transport() and modify its implementation to only support it for !ADB_HOST, but I'm not sure this adds much.

When running on the host, this function should perform exactly like the original code.

1517
Mon Apr 15 22:31:54 2013 +0000
Author: Kenny Root <1002975@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: STzMeiCA
UUID: TXsQr-us
Bytes: 331
I think I meant a USB device can say "send this packet to listener N."  I don't think there is any validation of device -> host "connections"  So you may intend to open a listener only for Device A, but Device B can also send things to that listener if it knows the number.

I could be wrong, but I remember looking at this before.

1517
Thu Oct 10 09:41:54 2013 +0000
Author: David Turner <1000411@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: TXsQr-us
UUID: e125cd90_c6536217
Bytes: 1545
I'm sorry, but I still don't understand. Can you give a concrete example?

Let's assume a malvolent USB device that implements a custom adbd daemon that tries to attack the adb server running on the host. According to protocols.txt, the device could send an OPEN(local-id, 0, <destination>) with <destination> crafted  in various ways:

* tcp:<port>, where <port> is adb-forwarded to a different device.
=> This allows the bad device to connect directly to a different one, however, this is already possible with the existing code base, so this patch doesn't change anything.

I wonder if we check for connections to tcp:5037 though, since this might give a _lot_ of control to the attacking device, but again, this is irrelevant for this specific change.

* host-serial:<serial>:forward:<local>;<remote>
=> This asks the host ADB server to create a redirection from host <local> port to <remote> port on a given device <serial>.
This won't work because only smart sockets can handle <host-prefix> commands, and they're never connected to a transport socket (from my reading of the current sources, it might be worthwhile to add some runtime checks / assertions here). Again, unrelated to this change.

* reverse:forward:<local>;<remote>
=> This will ask the ADB server to bind to host port <local>, and redirect connections to device port <remote>, i.e. this is asking for an explicit "adb forward" to the bad device. This won't work because 'reverse:' is only implemented if ADB_HOST is _not_ defined.

Maybe you're thinking of something else?

