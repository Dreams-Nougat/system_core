Revision: 4d713aad27f9678a3e1e8a7f33aeece834c1f9da
Patch-set: 8
File: init/service.cpp

232:0-234:5
Mon Oct 31 16:10:36 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 066eea3f_24a592ef
Bytes: 213
We only need this if uid_ is set.

Also, we should clear KEEPCAPS _after_ we set the uid as the assumption in the executables is that this is always clear unless they set it (i.e.: make them work for their crumbs)

232:0-234:5
Mon Oct 31 16:25:29 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 066eea3f_24a592ef
UUID: 662326ed_4d860daf
Bytes: 653
I don't think that's necessarily true. It's possible for a process to keep UID=0 but drop caps, and if you drop CAP_SETPCAP and the bounding set, you won't be able to gain those caps back.

As for KEEPCAPS, the capabilities(7) man page confirms it's cleared on execve(2):
SECBIT_KEEP_CAPS
"This flag is always cleared  on  an  execve(2).   (This  flag  provides the same functionality as the older prctl(2) PR_SET_KEEPCAPS operation.)

We could lock the secure bit if we were being extra paranoid but since we're dropping the bounding set, there's no extra caps that can ever be gained.

We could also set no-new-privs if we wanted to be extra paranoid.

232:0-234:5
Mon Oct 31 16:54:21 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 662326ed_4d860daf
UUID: 066eea3f_c4df5e4c
Bytes: 288
You misunderstand. KEEPCAPS _only_ is required so that setuid() does not drop the capability set. You only run setuid if uid_ is not zero. This is all about keeping attack surfaces minimized, do not ask for things you do not need. CAP_SETPCAP remains because you did not do a setuid() ...

232:0-234:5
Mon Oct 31 17:20:01 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 066eea3f_c4df5e4c
UUID: 662326ed_2db91923
Bytes: 133
Adding an uid_ check here is the right thing to do. I was just pointing out that settings caps without changing uid also makes sense.

245:12-245:64
Mon Oct 31 16:10:36 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 066eea3f_c4d67e50
Bytes: 317
You will need CAP_SETGID for this, but if we do this, do we want to specifically block CAP_SETGID for the exec? Either we do it, or the executable does it, but not both?

Hmm, maybe outside the cope of this change, come to think of it, if supp_gids is empty, maybe we should make sure setgroups empties the supp_gids?

245:12-245:64
Mon Oct 31 16:25:29 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 066eea3f_c4d67e50
UUID: 662326ed_8d676543
Bytes: 193
We don't. The only thing done above is settings KEEPCAPS. Capabilities are actually dropped below, in the SetCapsForExec() function, so at this point the process can still do whatever it wants.

245:12-245:64
Mon Oct 31 16:54:21 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 662326ed_8d676543
UUID: 066eea3f_245af20a
Bytes: 310
But that is the point, if we restrict/set the groups here, then we may not wish to allow the exec'd process to do so?

I recant in any case, because if we restrict it here, we should still allow the underlying process to restrict it further ... but my worry remains is that it could be allowed to grow the set.

245:12-245:64
Mon Oct 31 17:20:01 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 066eea3f_245af20a
UUID: 662326ed_cdd31d5e
Bytes: 770
Right. There's two issues:

1-We do not need CAP_SETGID for this specific call to setgroups, because in line 245 we have not yet dropped caps.

2-If the process expects to change UID/GIDs again (maybe to drop some GIDs, maybe to change UID to an even less privileged UID), the process should ask for CAP_SETUID/CAP_SETGID. Obviously CAP_SETUID/CAP_SETGID are very powerful capabilities, but note:

"3. If the effective user ID is changed from nonzero to 0, then the permitted set is copied  to the effective set."

Which means that asking for CAP_SETUID and changing the UID back to 0 won't allow the process to gain any extra caps: "permitted" is already the same as "effective" in the child process.

(It also means that dropping caps while running as root is useful.)

252:8-252:9
Mon Oct 31 16:10:36 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 066eea3f_84b3a635
Bytes: 37
expect we should clear KEEPCAPS here?

252:8-252:9
Mon Oct 31 16:25:29 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 066eea3f_84b3a635
UUID: 662326ed_ad6a290b
Bytes: 26
Why? The process is dying.

252:8-252:9
Mon Oct 31 16:54:21 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 662326ed_ad6a290b
UUID: 066eea3f_6464ead1
Bytes: 243
I tagged the fall-through, not the failure case.

If uid_ is set, and we have ran setuid, then KEEPCAPS has done its job and we do not need it anymore. This is based on the new code above which set KEEPCAPS in order for this mechanics to work.

252:8-252:9
Mon Oct 31 17:20:01 2016 +0000
Author: Jorge Lucangeli Obes <1076138@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 066eea3f_6464ead1
UUID: 662326ed_4d9f2d99
Bytes: 503
My reasoning is that this code does one of two things:

It either LOG(FATAL)s,
Or it drop caps (including the bounding set), and execve(2)'s, which means that KEEPCAPS is cleared.

Moreover, if we change the if clause in your first comment to only call prctl(KEEPCAPS) when uid_ is set, then we'll always try to setuid() here, which means that we'll either succeed or die.

In either of the cases, there does not seem to be a need to clear KEEPCAPS. Happy to add it if you think it's a good idea though.

