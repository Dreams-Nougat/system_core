Revision: 28416d6d33267f92768116e269966d61eac01db9
Patch-set: 2
File: adb/commandline.cpp

509:8-509:24
Tue Nov 10 01:19:34 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 369daed4_100f8a47
Bytes: 234
So this will make unix_read() take a buffer of size 1? I think this will break my simple assumptions in https://github.com/android/platform_system_core/blob/master/adb/sysdeps_win32.cpp#L3320 . I'll have to investigate this further...

509:8-509:24
Tue Nov 10 01:24:25 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 369daed4_100f8a47
UUID: 369daed4_3099e63d
Bytes: 201
for the pty-and-valid-escape-char case, yes. i initially had the read(2) use (buffer_size - 1) so i could just memmove up or down, but then i realized that you could have more than one ~ in the buffer.

509:8-509:24
Tue Nov 10 03:11:07 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 369daed4_3099e63d
UUID: 369daed4_f0b91e3c
Bytes: 592
Ok, I tested it on Windows and this breaks things. Repro: 1) adb shell, 2) press up arrow and it hangs forever (_console_read() returns -1 with errno == ENOMEM).

I wrote _console_read() to assume that the buffer is always big enough to hold a full terminal sequence, so that I wouldn't have to keep track of an input queue buffer.

I see two options:

1. Make _console_read() maintain an input queue buffer so it can return one byte at a time.
2. Make stdin_read_thread_loop() somehow do the 'coughing up' with memmove(), etc. correctly. (Sounds like it is harder than it sounds?)

Thoughts?

