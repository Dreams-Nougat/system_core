Revision: a70fd734cc518f08d2def844fe38f9aae2d8c060
Patch-set: 5
File: sdcard/sdcard.c

978
Mon Aug 13 17:28:48 2012 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAISH///rY=
Bytes: 228
wait, this is wrong. endptr will non-NULL on success. you also need to check for endptr != argv[2] and that *endptr == '\0'. Only then do you know that the conversion is valid and the entire string was valid.

Did you test this?

978
Mon Aug 13 17:35:16 2012 +0000
Author: Edwin Vane <1010717@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAISH///rY=
UUID: AAAIRn///0U=
Bytes: 296
It was before the weekend but I'm sure it's tested. The strtoul manpage claims that endptr will be NULL on success. Since argv[2] isn't NULL the only situation endptr will be NULL is upon success. If it *is* NULL then we check for an out-of-range number (negative numbers count as valid numbers).

978
Mon Aug 13 17:44:13 2012 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAIRn///0U=
UUID: AAAIR3///x0=
Bytes: 495
From manpage:
If  endptr is not NULL, strtoul() stores the address of the first invalid character in *endptr.  If there were no digits at all, strtoul() stores the original
       value of nptr in *endptr (and returns 0).  In particular, if *nptr is not '\0' but **endptr is '\0' on return, the entire string is valid.


Note that it defines endptr as ** in the manpage, so your &endptr will always be non-null when you pass it into the function. So, it will always store an address into endptr.

978
Mon Aug 13 18:00:41 2012 +0000
Author: Edwin Vane <1010717@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAIR3///x0=
UUID: AAAIRn///xg=
Bytes: 224
Argh! How embarrassing. You're right of course. Which implies this couldn't have been tested properly. This is what happens when I'm working with several versions of the android code base at the same time. Fix forthcoming...

