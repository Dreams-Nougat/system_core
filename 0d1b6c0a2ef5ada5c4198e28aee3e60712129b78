Revision: 0d1b6c0a2ef5ada5c4198e28aee3e60712129b78
Patch-set: 4
File: adb/sysdeps_win32.cpp

3512
Fri Oct 23 00:18:46 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3675adb9_fc0b5d65
Bytes: 103
how many callers are there of these? should we just rewrite them to use UTF8ToWide/WideToUTF8 directly?

3512
Fri Oct 23 00:36:31 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3675adb9_fc0b5d65
UUID: 166d09ed_80cbdada
Bytes: 182
~14 callers to widen(), ~8 callers to narrow(). I think it makes sense to rewrite (especially because I like a non-fatal error-path), let me know the timing: in this commit or after?

3512
Fri Oct 23 04:46:23 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 166d09ed_80cbdada
UUID: 968019c6_9f8b3f5e
Bytes: 50
either's fine, i was just curious about direction.

3512
Fri Oct 23 05:08:44 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 968019c6_9f8b3f5e
UUID: 56a1415d_651b3cbb
Bytes: 95
Ok, I'm thinking as a separate commit so that the stuff is broken for a minimal amount of time.

File: base/include/base/u8.h

17
Fri Oct 23 00:18:46 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56a1415d_c290064a
Bytes: 59
why u8 rather than utf8? (for the files and the namespace.)

17
Fri Oct 23 00:36:31 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56a1415d_c290064a
UUID: b6699de6_3daeb706
Bytes: 143
I think I was influenced by the C++ string literal prefix of 'u8', but it doesn't matter to me. Just give the word and I can change u8 => utf8.

17
Fri Oct 23 04:46:23 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6699de6_3daeb706
UUID: d6661112_9ed9fd7d
Bytes: 43
yeah, u8's too new, man from the future :-)

17
Fri Oct 23 05:08:44 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6661112_9ed9fd7d
UUID: 3675adb9_8749b6a4
Bytes: 48
Ok, I'll rename u8 stuff to utf8 in the next PS.

59
Fri Oct 23 00:18:46 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6661112_7eed09ba
Bytes: 263
why don't we want to be able to just #include this file and have open et cetera just work, even on Windows? shouldn't the 'using's be in this file? (and if the reason is that we want the "wide" functions independently, let's just move them into their own header.)

59
Fri Oct 23 00:36:31 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6661112_7eed09ba
UUID: d6661112_3e9b1141
Bytes: 375
So your idea is to put "using android::base::u8::open,unlink,etc" in this file? Then the caller would do the following?

namespace { // gotta put your code in a namespace
#include "base/u8.h"
void SomeFunction() {...
} // namespace

I can try prototyping that, just give me suggestions on the filenames for the files containing the wide funcs and this file full of "using's".

59
Fri Oct 23 04:46:23 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6661112_3e9b1141
UUID: 56a1415d_25c3f46c
Bytes: 39
why do we need the anonymous namespace?

59
Fri Oct 23 05:08:44 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56a1415d_25c3f46c
UUID: f66f95e4_487e479d
Bytes: 304
When I tried:

using android::base::u8::open;
void SomeFunc() {
open(...

Building host_cross_libbase_test said:

error: ‘open’ is already declared in this scope
 using android::base::u8::open;
                          ^
Weird, huh? Ideas?

Let me know what you think and I can continue prototyping.

59
Fri Oct 23 17:55:29 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f66f95e4_487e479d
UUID: b6699de6_6ba0e9cc
Bytes: 578
It makes sense that we can't bring in a second open() function with the same signature to the global namespace, I'm not sure there's any way to override global functions like that unless they are weakly linked.

What about using the preprocessor to reroute open/unlink instead? It's the only way I can think of to automatically replace these functions without requiring the user to be in a namespace, but it may be preferable to stick with namespace + using instead.

  #ifdef _WIN32
  #define open ::android::base::u8::open
  #define unlink ::android::base::u8::unlink
  #endif

59
Fri Oct 23 18:03:03 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6699de6_6ba0e9cc
UUID: 96df3923_be3d19f7
Bytes: 331
yeah, that's what we have in adb and what i assume spencer's trying to get away from, but it does seem like reality is trying to push us back in that direction.

i wonder how much of this goes away if we delete from libbase  the stuff we can get from libchrome? (iirc our Read/Write functions are a superset of the libchrome ones.)

59
Fri Oct 23 22:05:40 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96df3923_be3d19f7
UUID: 76dac536_63f4d6f5
Bytes: 993
To use libchrome's base::ReadFileToString(), we'd need to pass it a FilePath object, which uses std::wstring internally on Windows and std::string elsewhere. To get a FilePath object, you can use `static FilePath FilePath::FromUTF8Unsafe(const std::string&)' or just go hog-wild and use FilePath all over the adb codebase.

Let's face it, libchrome has a ton of useful stuff, it just requires the caller to 'get religion' and use its APIs the way they want them to be used. Remember the headaches we had getting mkdirs() to work? libchrome has FilePath and base::CreateDirectory() to solve that in a sec.

So it's up to you guys what direction you want adb/libbase to take: POSIX-y like adb is generally right now, or more platform-neutral with various abstractions from libchrome. There's a lot to consider like what future people working on adb/base will be familiar with, will you be able to fix bugs in libchrome, etc.

Let me know what you guys decide and then I can continue prototyping.

59
Fri Oct 23 22:05:40 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6699de6_6ba0e9cc
UUID: 36e4cdf6_4116f663
Bytes: 1607
Yeah, it does make sense that you can't bring in a second open() -- that's why adding an anonymous namespace works, because you're importing an open() function into an empty anonymous namespace.

I did the preprocessor tricks in adb's sysdeps.h and although it works, it is somewhat fragile. See what I had to do with #define stat adb_stat for an example. Or the fact that a struct member named open will probably fail to compile with the macros in your comment. Basically, the macro technique is fragile and maybe ok for the scope of a single app (like adb), but I'm hesitant to recommend it for a base library that is potentially used by more code (which I may not even be compiling).

But really the call is up to you guys, I'll go with whatever direction you guys want. My primary goal is just to get adb stable on Windows, so I'm happy to go along with whatever big designs you guys want.

Stepping back, I see only a few ways to solve the big issues:

1. Make new APIs and have everyone call those. This might be android::base::utf8::open(), or it might be libchrome's base::file::OpenFile(const FilePath&), or some other abstraction. Other codebases that I've worked on have gone this route.

2. Let code call open() and use source code tricks (macros or using) to redirect calls to substitutions. This is what adb does right now with macros.

3. Let code call open() and use linker tricks (--wrap or some other symbol overriding technique, I think there is even an __asm() trick that I saw in bionic). I haven't tried this since it seems even more fragile and hard to comprehend.

I'm open to ideas.

59
Fri Oct 23 22:27:43 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76dac536_63f4d6f5
UUID: 96df3923_c4869218
Bytes: 773
I forgot to mention that libchrome also has other stuff that libbase provides:

https://android.googlesource.com/platform/external/libchrome/+/master/base/logging.h
https://android.googlesource.com/platform/external/libchrome/+/master/base/strings/stringprintf.h
https://android.googlesource.com/platform/external/libchrome/+/master/base/strings/string_split.h
https://android.googlesource.com/platform/external/libchrome/+/master/base/strings/string_util.h

So in theory, perhaps one could go hog-wild and kill most of libbase in favor of libchrome. I don't have a horse in the race (and I don't know the real purposes of libbase and libchrome), just sayin'. Probably a Googler with more context around who uses libbase and libchrome could analyze this situation better...

59
Fri Oct 23 22:58:06 2015 +0000
Author: David Pursell <1078119@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96df3923_c4869218
UUID: b6d8bd3b_25757a8b
Bytes: 545
Ugh yeah forgot about someone wanting to declare their own thing called open and how the macros would behave. Gross.

Would it be fairly straightforward to go with this "using" technique to get Windows fixed, but rather than re-implementing these 6 conversion functions link libchrome and use the existing functions instead? Or would that also involve bringing in a lot of additional libchrome stuff?

I'm thinking that way we can punt on the larger unification question for now but at least we aren't adding more duplicate code between the two.

59
Fri Oct 23 23:10:26 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6d8bd3b_25757a8b
UUID: b6d8bd3b_a587caa4
Bytes: 423
I tried building the target libchrome-host, which required external/libevent and external/modp_b64, but it ended up building for Linux, not Windows. So I tried building the targets host_cross_libchrome-host and host_cross_libchrome, but neither worked.

So it might be a while before I can get libchrome building, hence why I was suggesting that a Googler might be in a better position to integrate in another component. :)

59
Sat Oct 24 00:27:19 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6d8bd3b_a587caa4
UUID: 96df3923_47bfe499
Bytes: 789
Ok, I tried to get libchrome building for Windows:

* I figured out how to use LOCAL_MODULE_HOST_OS to try to get libchrome-host to compile for Windows.
* I had to remove its dependency on libevent-host since I don't think it uses libevent on Windows.
* When compiling, it gives an error about #pragma warning being unrecognized. Clearly this code is only designed to compile under Visual Studio when compiling for Windows.
* The next warning was that -Wno-deprecated-register was unrecognized. Clearly this code is not designed to compile with the current version of gcc used for Windows in AOSP.

So I'm a bit skeptical that libchrome in its current state is really meant to be used by other projects.

Anyway, next week, let me know what you guys think about the overall direction here.

File: base/u8.cpp

38
Fri Oct 23 00:18:46 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f66f95e4_a2e70447
Bytes: 162
no, let's definitely not consider anything other than deleting libutils :-)

we really do need to find the time to work on Win32 libc++ though. hopefully in 2016.

38
Fri Oct 23 00:36:31 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f66f95e4_a2e70447
UUID: 166d09ed_c032328c
Bytes: 115
Ok, so libutils is crufty, I gather? Anyway, let me know if I should edit libutils/Unicode.cpp out of this comment.

38
Fri Oct 23 04:46:23 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 166d09ed_c032328c
UUID: 56a1415d_e5dc2c48
Bytes: 188
very crufty.

the libchrome vs libbase question is an excellent one, and we should really come up with an actual plan on that front, but libutils is definitely something we'd like to kill.

38
Fri Oct 23 05:08:44 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56a1415d_e5dc2c48
UUID: 968019c6_4aaf23ba
Bytes: 52
Ok, I'll remove it from the comments in the next PS.

