Revision: ad61f2b2594306bb432a8766d0f2bbd82f618f03
Patch-set: 2
File: init/capabilities.cpp

89:45-89:70
Fri Dec 16 03:18:04 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_b7e6a2cd
Bytes: 226
Is this needed anymore? Service::ParseCapabilities errors out if last_valid_cap >= to_keep.size(), so this is an impossible to occur condition without "cap < to_keep.size()" also triggering.

(same comment on line 109 and 137)

148
Fri Dec 16 03:33:54 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_5771cef6
Bytes: 150
Here you return an int, but below you return an unsigned long. I suspect you should return an unsigned long here too. At a minimum, it's inconsistent.

File: init/service.cpp

320:0-323:5
Fri Dec 16 03:18:04 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_d7723e50
Bytes: 513
This is stricter than necessary. If anyone ever upgrades the kernel, for instance, without upgrading this file / the libc header files, init will fail to start services, which will make bringup slightly harder.

Instead, perhaps it makes more sense to only error out if the config file requests a capability not supported by the kernel. How about, around line 327, something like:

  int cap = LookupCap(arg);
  if ((cap == -1) || (cap > GetLastValidCap())) {
    *err = StringPrintf("...");
    return false;
  }

327:8-327:11
Fri Dec 16 03:33:54 2016 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa6fafa9_d7931ee7
Bytes: 49
int vs unsigned long for capability integer type.

