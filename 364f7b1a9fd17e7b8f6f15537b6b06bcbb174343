Revision: 364f7b1a9fd17e7b8f6f15537b6b06bcbb174343
Patch-set: 1
File: init/init.c

260
Tue Apr 24 22:10:01 2012 +0000
Author: JP Abgrall <1005480@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAE73///0c=
Bytes: 61
No check, so a slightly typo-ed limit name will go unnoticed.

File: init/init_parser.c

759
Tue Apr 24 18:44:59 2012 +0000
Author: JP Abgrall <1005480@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAE73///1o=
Bytes: 61
Shouldn't this barf if args[1] isn't one of the valid limits?

759
Tue Apr 24 20:31:54 2012 +0000
Author: Bjorn Andersson <1011077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAE73///1o=
UUID: AAAE8n///9I=
Bytes: 355
Looking through the implementation this follows the general pattern of not checking return values when parsing parameters. See e.g. decode_uid() or most of the different forms of atoi().

So this follows the general pattern of the "parser" over proper validation.

Please let me know if you prefer a version with this check in place. What about the atois?

759
Tue Apr 24 22:10:01 2012 +0000
Author: JP Abgrall <1005480@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAE8n///9I=
UUID: AAAE73///0g=
Bytes: 644
I would prefer a version that doesn't silently succeed and not do what is expected.

In the decode_uid() case, the return value is actually mostly unusable and will cause init to fail later e.g. when setuid() is invoked.

But in the case of rlimit, there is no failure check anywhere.

So either check setrlimit()'s return value, or check that the decoded resource isn't RLIM_NLIMITS. Complaining during parsing has the advantage that the parse_error() will provide an actionable message with filename + linenum as opposed to some much much much later error during service startup (think adb which doesn't get turned on until somebody says to).

