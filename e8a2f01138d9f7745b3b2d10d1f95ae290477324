Revision: e8a2f01138d9f7745b3b2d10d1f95ae290477324
Patch-set: 1
File: init/devices.c

822
Mon Apr 22 18:04:21 2013 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: TvWs11bA
Bytes: 95
is there a uevent that triggers this or are you just checking this en every uevent you receive?

822
Mon Apr 22 18:57:13 2013 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: TvWs11bA
UUID: TwoN-wG8
Bytes: 685
selinux_status_updated() simply checks a sequence number in a read-only shared page mapped from the kernel by the  selinux_status_open() call to see if it has changed since the last call to selinux_status_updated().  So it is checking on every uevent but the check requires no system calls in the common case.  Implementation of selinux_status_updated() can be found in the corresponding change uploaded for external/libselinux with the same change-id since it is a dependency.
selinux_status_open()/selinux_status_updated() will fall back to checking a NETLINK_SELINUX socket on older kernels that do not support /sys/fs/selinux/status, but that would only be true for Linux < 2.6.37.

822
Wed Apr 24 07:54:11 2013 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: TwoN-wG8
UUID: T9oylB0s
Bytes: 161
The question, though, is if you are guaranteed that a uevent is generated at the point when the reload is necessary, or will it be delayed until the next uevent?

822
Wed Apr 24 13:12:27 2013 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: T9oylB0s
UUID: UA1-JS6A
Bytes: 501
ueventd doesn't need to process the reload immediately; it only needs to ensure that it reloads its configuration before it next looks up an entry in it (i.e. selabel_lookup) to label a device node.  There is no uevent generated by the reload, so the handling is delayed until the next uevent, but this should be harmless.  The alternative approach would be to add a descriptor to a NETLINK_SELINUX socket, which does get a notification upon reload, to the poll()'d set in ueventd and handle it there.

822
Sat Apr 27 21:26:59 2013 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: UA1-JS6A
UUID: UKTlzLx8
Bytes: 171
Hmm, this doesn't seem like enough actually. What happens when the policy modifies an existing node. With this code, you wouldn't update it until it got re-created, right?

822
Sat Apr 27 21:30:42 2013 +0000
Author: William C Roberts <1013433@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: UKTlzLx8
UUID: UOelatQM
Bytes: 140
The policy determines the contexts for created nodes from this point forward. Handling nodes already assigned a context is a separate issue.

822
Tue Apr 30 12:49:17 2013 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: UKTlzLx8
UUID: UM69m.ZU
Bytes: 299
That is true, but was also true of the prior code; restarting ueventd did not cause existing nodes to be relabeled either.  Unclear as to whether we want that behavior automatically or if it should only be done via explicit restorecon by whatever dropped the updated policy or upon on the next boot.

822
Tue Apr 30 15:54:19 2013 +0000
Author: William C Roberts <1013433@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: UM69m.ZU
UUID: UOSwlOxc
Bytes: 385
Yes, exactly. 

Their are usually two types of policy reloads, those affecting early boot and those after. Dynamic reloads can affect the late boot process, after data is mounted. An example of where this is handy is the following:
1. You are well past boot and a driver gets insmod'd
2. You need to update that label

Now you can rmmod, reload policy, insmod and it works as expected.

