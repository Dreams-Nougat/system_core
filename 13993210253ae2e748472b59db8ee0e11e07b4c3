Revision: 13993210253ae2e748472b59db8ee0e11e07b4c3
Patch-set: 1
File: crash_reporter/crash_sender

186
Sat Sep 12 17:27:37 2015 +0000
Author: Mike Frysinger <1040868@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 44997af8_dcd50dd3
Bytes: 125
this effectively clears the high bit so we get 31 bits of randomness

please update the comment above highlighting this issue

186
Sun Sep 13 07:42:10 2015 +0000
Author: Steve Fung <1076778@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44997af8_dcd50dd3
UUID: 848ff2ac_c728d4c8
Bytes: 1295
I'm a little hazy on my understanding of shell expressions and variable represenation in the shell, but I made this change based on this part of the mksh man page (http://linux.die.net/man/1/mksh):

---

Expressions are calculated using signed arithmetic and the mksh_ari_t type (a 32-bit signed integer), unless they begin with a sole '#' character, in which case they use mksh_uari_t (
a 32-bit unsigned integer).

---

It was my understanding that when ${random} gets set, it would be set as a string as the output of the `od` call (and thus signed vs unsigned doesn't matter to this variable), and the `od` call would return a 32 bit unsigned int as a string.  Then for the arithmetic expression, the leading # character would tell the shell to use an unsigned int, and thus convert the input string value using all 32 unsigned bits.

Here's my local test I ran in the emulator, which unless my initial number for a max unsigned int is incorrect (which var1 suggests it isn't), should include setting the high bit:

# local random=4294967295                                                            

# echo $random                                                                 

4294967295

# local var1=$((random))

# echo $var1

-1

# local var2=$((#random))

# echo $var2

4294967295

186
Mon Sep 14 20:19:46 2015 +0000
Author: Mike Frysinger <1040868@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 848ff2ac_c728d4c8
UUID: 64c59ecc_88da3753
Bytes: 400
the # prefix is a mksh-specific feature.  we've been coding to POSIX rather than replace on shell-specific feature with a different one.

we can do this in a few ways:

(1) change -N4 to -N3 and stick to 24 bits and assume we'll never have a system where sizeof(signed long) < 4
(2) mask out the sign bit: $(( random & 0x7fffffff ))
(3) invert the sign ourselves: $(( random < 0 ? -random : random ))

