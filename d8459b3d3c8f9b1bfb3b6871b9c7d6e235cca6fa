Revision: d8459b3d3c8f9b1bfb3b6871b9c7d6e235cca6fa
Patch-set: 3
File: adb/transport.cpp

46:7-46:20
Wed Aug 26 22:55:57 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 048f817d_5bf7794d
Bytes: 546
Technically tsan is clearly correct.  This is a data race, which has undefined behavior.  Whether it can actually fail in practice is complicated.  In the old version, I think it would be correct, for example, for the compiler to remove the second t->kicked load, since it can assume the first one doesn't race, and hence the value can't change.  That would allow t->kick(t) to execute more than once, which certainly violates the intent of the code.

I suspect no current compiler does that.  I wouldn't be surprised if people are working on it.

46:7-46:20
Thu Aug 27 17:42:21 2015 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 048f817d_5bf7794d
UUID: a47f9520_3e57fcd8
Bytes: 261
But I can assume there is a load operation with memory_order_acquire in adb_mutex_lock. No memory accesses in the current thread can be reordered before this load. So I think the second t->kicked should never reuse the content of the first t->kicked. Not right?

46:7-46:20
Thu Aug 27 17:58:54 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a47f9520_3e57fcd8
UUID: 84253145_a748db81
Bytes: 895
I'm assuming more devious reasoning by the compiler than you are.  The compiler may assume that the first load of t->kicked is not involved in a data race, since the language spec says so.  Under that assumption, the value of t->kicked cannot change between the two loads.  Thus it "knows" the second load has to return the same value as the first.

If the first load were not there, you would be right that the compiler could not move the load out of the critical section.  But the load outside the critical section gives the compiler information (in this case false) about what might be concurrently modified.  Taking advantage of that introduces the possible bug here.

All of this assumes that the compiler understands some things about adb_mutex_lock, which it probably doesn't.

The bottom line is really that we need to fix such tsan-reported bugs before compilers really get this clever.

