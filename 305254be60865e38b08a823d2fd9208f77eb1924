Revision: 305254be60865e38b08a823d2fd9208f77eb1924
Patch-set: 6
File: adb/sysdeps_test.cpp

253:17-253:29
Wed May 18 20:36:36 2016 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d7f6229d_85cd76cc
Bytes: 228
I like the idea of testing try_lock() after lock(), but this suggests that the behavior may be undefined:

http://en.cppreference.com/w/cpp/thread/mutex/try_lock

Something to watch out for in case this test fails in the future?

253:17-253:29
Wed May 18 21:21:40 2016 +0000
Author: Josh Gao <1079148@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d7f6229d_85cd76cc
UUID: d7f6229d_8096044c
Bytes: 271
Yeah, you're right. It seems that (at least my reading of) POSIX says that pthread_mutex_trylock has defined behavior in this case, so we can probably get away with it here?

(Also noticed in reading the spec that destroying a mutex while it's held is UB, so fixed that.)

253:17-253:29
Wed May 18 21:25:37 2016 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d7f6229d_8096044c
UUID: d7f6229d_20e3d0ed
Bytes: 363
I guess I meant that if the spec says that if lock+try_lock is UB, if you write a test to do that and even if it passes right now, in the future it might not pass and might crash or have general weirdness. So do you want to be on the hook for that in the future?, or just comment out that portion of the test. You guys are maintaining the code, so it's your call.

253:17-253:29
Wed May 18 21:44:26 2016 +0000
Author: Yabin Cui <1056364@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d7f6229d_20e3d0ed
UUID: d7f6229d_808444e8
Bytes: 275
I think the try_locks in the tests are fine. I think the cppreference.com means try_lock can return false even if the lock is just released by other threads. But in L286, the try_lock is called just after m.lock(), I can't imagine any implementation can have it return false.

253:17-253:29
Wed May 18 22:20:19 2016 +0000
Author: Josh Gao <1079148@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d7f6229d_808444e8
UUID: d7f6229d_e08b8877
Bytes: 679
The standard says no: "Requires: If m is of type std::mutex, std::timed_mutex, or std::shared_timed_mutex, the calling
thread does not own the mutex"

Before I added this, the implementation of mutex I had did something that was technically legal (since it was UB), but still unexpected. Even if something technically is UB, we should either detect it and abort, or do something sensible. I think it's worth the potential failure in the future (which is probably unlikely?) to ensure this.

(And if it ever does break, it should probably be regarded as a bug in the C++ implementation. Just because the standard gives you license to hurt your users doesn't mean that you should.)

