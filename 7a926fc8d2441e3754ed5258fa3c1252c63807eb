Revision: 7a926fc8d2441e3754ed5258fa3c1252c63807eb
Patch-set: 1
File: adb/usb_linux.cpp

318:4-318:18
Thu Jul 23 23:05:22 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ed1a4eb3_c63ca24c
Bytes: 248
So if a timeout occurs, the URB is still active/pending, we'll return from this function, the buffer becomes stale, and random data could be written to the device? I'm guessing that the OS does buffering so this doesn't actually happen in practice?

323:12-323:52
Thu Jul 23 23:05:22 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ad14d688_e4a39af6
Bytes: 114
The old code broke out of the loop if h->urb_out_busy==0 && urb->status != 0. Was that just a bug in the old code?

552:12-552:31
Thu Jul 23 23:05:22 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ad14d688_67d4cc32
Bytes: 45
Doesn't the destructor already close this fd?

