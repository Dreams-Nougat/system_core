Revision: 76b54e4196160030b40c9ecc3078e90edfa57f45
Patch-set: 1
File: adb/adb.h

28
Tue Jul 21 00:28:05 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 383666c8_b2294695
Bytes: 204
it might be wise to rename this MAX_PAYLOAD_V2 to prevent the possibility of merge problems silently changing code from 4KiB to 256KiB.

did you experiment with other sizes? why 256KiB and not, say, 1MiB?

28
Tue Jul 21 11:36:57 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 383666c8_b2294695
UUID: 0d432251_8ffb15b2
Bytes: 779
I created a new MAX_PAYLOAD_V2 macro and defined MAX_PAYLOAD to it. I don't want to pollute with the code with references to MAX_PAYLOAD_V2 because I think it makes the code less readable, but if you want I can change it.

I experimented with various packet sizes and further increase of the packet size have almost no impact on the push/pull speed on the other hand it increases the latency linearly (because of the USB transfer speed). With 256KiB packets the packet latency is ~8ms what means that any service have at least this latency if a push/pull using the connection with full load. For "real time services" (e.g. logcat or shell) I think this latency is acceptable but a further increase will hurt the user experience, because the practical latency is higher then this.

28
Wed Jul 22 00:35:59 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d432251_8ffb15b2
UUID: ad7a16a8_faea81e5
Bytes: 149
i don't understand your point about increasing latency --- this is the max payload size; we'll only send as many bytes as are actually in the packet.

28
Wed Jul 22 17:28:12 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ad7a16a8_faea81e5
UUID: 2d3aa6f6_e0e44219
Bytes: 920
If we have an "adb pull" and an "adb shell" running at the same time with the same device then the "adb pull" will put high load of 256KiB packets onto the connection. If the shell service want to send a message also (e.g. stdout of a shell command) then it will try to use the same stream to write the data to the host because we have only 1 USB write endpoint. It means that when the shell service want to send a packet then it will have to wait until the packet currently transferred is finished what will be most likely a large packet from the file sync service. Because of it the latency of the shell service is affected by the packet size used by the file sync service.

I agree that this isn't a major issue but it gives us an upper limit for the packet size. Increasing the packet size over 256KiB have almost no effect on the push/pull speed while increasing this effect to a level where it can be user visible.

File: adb/protocol.txt

64
Tue Jul 21 00:28:05 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d143a33_7cd9b5a3
Bytes: 317
this isn't really true, though, is it?

"Currently, version=0x01000000 and maxdata=256*1024. Older versions of adb hard-coded 4096, so CONNECT and AUTH packets sent to a device must not be larger than that because they're sent before the CONNECT from the device that tells the adb server what the device can support".

64
Tue Jul 21 11:36:57 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d143a33_7cd9b5a3
UUID: 2d0b8619_987135d3
Bytes: 44
Updated the wording based on you suggestion.

File: adb/usb_linux.cpp

455
Tue Jul 21 00:28:05 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b83896b1_33b9d035
Bytes: 83
not any more; we send a zero-length packet.

(you could combine the two 'if's too.)

455
Tue Jul 21 11:36:57 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b83896b1_33b9d035
UUID: 2d0b8619_d867ad14
Bytes: 4
Done

474:19-474:22
Tue Jul 21 00:59:34 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 185442e3_245d0abe
Bytes: 103
Have you considered making this same change to usb_windows.cpp, or is that out-of-scope of your change?

474:19-474:22
Tue Jul 21 01:08:36 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 185442e3_245d0abe
UUID: 383666c8_f28f3e7f
Bytes: 355
(i've been assuming that their plan is to make sure that the current change doesn't _break_ Mac or Windows and then worry about improving those platforms in separate changes. but, yes, obviously improving Windows is the most impactful change. actually, the Mac API seems to already just make one call, so there's nothing for us to do there. just Windows.)

474:19-474:22
Tue Jul 21 11:36:57 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 383666c8_f28f3e7f
UUID: cd24aaaf_ad749dc2
Bytes: 418
At the moment I don't have a Windows environment to test it on Windows but I plan to make that change after this CL.

On Windows currently we do 1 write (with full data) and several reads (with 4096 chunks). Changing it to make only 1 read makes sense (and I plan to do it), but I don't expect it to have measurable impact on the speed because the communication on the wire done independently of how much we read here.

474:19-474:22
Tue Jul 21 21:27:11 2015 +0000
Author: Spencer Low <1065256@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd24aaaf_ad749dc2
UUID: 4d70bac3_3cc23d7c
Bytes: 214
Makes sense, thanks. BTW, I think the hard thing to test on Windows is to find a device that uses the 'legacy kernel driver' (which has been deleted from AOSP, but might be in use by 3rd parties) instead of WinUsb.

File: adb/usb_linux_client.cpp

218
Tue Jul 21 00:28:05 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8568eec_15faf4b2
Bytes: 174
that's just read(2). so it seems more likely that this is actually a limitation in the usb device driver. i'm surprised that this would only affect reading and not writing...

218
Tue Jul 21 11:36:57 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f8568eec_15faf4b2
UUID: cd24aaaf_8d71e1d2
Bytes: 683
I changed the comment to blame the device driver but I don't know how can I check who exposes this limitation.

I don't know why it effects only the read and not the write (possibly the driver have a read buffer, but not a write buffer), but if the write works with bigger sizes then we have to use it because doing chunked write slows down the communication because each write will result in a separate, synchronous URB request what have 50-200us latency. If we run into a device where we want to ship the new adbd and it don't support larger writes then we should implement a fallback (e.g. when we got a EINVAL back) but I expect it to work in all case where we want to deploy it.

218
Wed Jul 22 00:35:59 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd24aaaf_8d71e1d2
UUID: 4dd51ace_e6a984db
Bytes: 7
ccross?

218
Wed Jul 22 01:06:38 2015 +0000
Author: Colin Cross <1002751@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4dd51ace_e6a984db
UUID: 4dd51ace_bac6303b
Bytes: 323
There are two kernel implementations, f_adb.c and f_fs.c.  This code is for the f_adb.c interface.  In f_adb.c, adb_read has:

        #define ADB_BULK_BUFFER_SIZE           4096

        if (count > ADB_BULK_BUFFER_SIZE)
                return -EINVAL;

I don't see any equivalent limitation on the newer f_fs.c interface.

218
Wed Jul 22 01:08:42 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4dd51ace_bac6303b
UUID: ad7a16a8_9ae02d8d
Bytes: 166
ah, now i get the significance of the "_adb_" in these names. makes sense. that lets us clarify the comment (and not worry about this too much going forward). thanks!

218
Wed Jul 22 17:28:12 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ad7a16a8_9ae02d8d
UUID: cd3e6aec_5dd87b1d
Bytes: 39
Clarified comment based on suggestions.

