Revision: ce482add9b3f1a5d8d1103c9a9d62b8bca44976c
Patch-set: 2
File: logcat/logcat.cpp

552
Fri May 29 17:52:03 2015 +0000
Author: Todd Kjos <1069543@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b91fb853_d5d77cb6
Bytes: 88
Should the case logic be moved to a separate function so this function is more readable?

552
Fri May 29 18:07:29 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b91fb853_d5d77cb6
UUID: b91fb853_f5d03871
Bytes: 53
This is on-par with the other selections, but agreed.

566
Fri May 29 18:20:13 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b91fb853_f895cd10
Bytes: 109
these .data() should really be .c_str() (though, yes, you'll get away with it on our current implementation).

580
Fri May 29 18:20:13 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ed56c9ec_5f6b979f
Bytes: 4
"re"

581
Fri May 29 18:20:13 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d54fde2_0919ec79
Bytes: 469
this is unsafe. fclose(NULL) will segfault. you either have do the fopen into a raw pointer and only define your unique_ptr when you can initialize it with a known non-null FILE*, or you could replace this with something like this instead:

  std::string file;
  if (android::base::ReadFileToString(file_name, &file)) {
    for (const auto& line : android::base::Split(file, "\n")) {
      ...
    }
  }

(which would also let you go backwards as easily as forwards...)

586
Fri May 29 17:52:03 2015 +0000
Author: Todd Kjos <1069543@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d54fde2_b7cd98e2
Bytes: 203
Optimization oppty: Have you tried this with a set of large log files? We know we want the last entry, so it would save some time to work backwards from the end instead of going through the whole file...

586
Fri May 29 18:07:29 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d54fde2_b7cd98e2
UUID: ed56c9ec_1faaef7d
Bytes: 773
We would have to use mmap interface to work backwards with any efficiency. mmap has its readability/maintenance options.

We are not assuming the log entries are in time order (!) although 99.99% of the time they are.

logcat is a user program with no need for tons of optimizations; I have found this rips through 16MB of data (as configured for logcatd) in less than 200ms. The optimization does not appear to be required on the scale we use in Android.

In all common cases we hit the basename file _first_ (because of how the rotate algorithm works) and break out below very quickly; so we are not pouring through all the files in any case. We only do so if there are no timestamps found in the basename file which can only happen if logcatd dies or the system reboots.

589:0-591:29
Fri May 29 20:07:02 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d54fde2_0cc81a27
Bytes: 756
This algorithm has to handle the fact we do NOT have the year placed into the timestamp data and log_time::strptime fills in the current year sans one parsed, and a wrap around to January will result in the current time being lower than the maximum discovered in the file(s).

mitigation: (plan A)
- filter out all timestamps higher than the current time

mitigation: (plan B)
- collect all the matching filenames first
- reverse sort the filenames before going through them (NB: the ext4 filesystem and the dynamics for normal operation of logcat -f will readdir in this order anyways, but not worth counting on)
- reverse scan the files in turn looking for a valid timestamp
- call it a day once a timestamp is found
- too complex for ease of maintenance

