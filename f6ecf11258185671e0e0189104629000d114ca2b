Revision: f6ecf11258185671e0e0189104629000d114ca2b
Patch-set: 2
File: include/nativebridge/native_bridge.h

231:9-231:24
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3d8cca86_d6803412
Bytes: 420
Why use this instead of the legacy one? I remembered you want use it to verify if a library is accessible in one namespace once, is it?

The legacy one is just to verify Machine type of a .so. If the .so should be loaded by native bridge (arm library on x86 devices for example), the needs_native_bridge will be set, and native bridge is responsible for this library instead of dynamic linker. I think we should keep it.

File: libnativeloader/native_loader.cpp

149:25-149:48
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bdc43ad3_24dd32eb
Bytes: 82
NativeBridge cannot determinate whether itself should start on a app library path.

152:26-152:42
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bdc43ad3_64fe0a3b
Bytes: 764
By this design, a namespace uses NativeBridge or not?
I understand you want the library of an application is pure one ABI. We are the same.

But, Android is so diverse, there are many apps packed x86 & arm library together and declare itself as an x86 app. And there are other apps dynamically download x86 library but declare itself as a ARM app.
By this new "IsSupport/namespace" design, these apps cannot be compatible with Intel devices. Maybe we can follow the original design "check if nativebridge is needed library by library?"

And, can we bridge the namespace of nativebridge and linker? We really need a way to handle the cases talked above.
We hate these apps much more than you guys, trust me. but we cannot persuade them to develop decent apps.... :(

302:9-302:25
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bdc43ad3_44494ea5
Bytes: 1038
I think NativeBridgeInitNamespace should always be called.

As far as I understand, InitPublicNamespace() can be called when:
1. app is just started, dex loaded by Android, and ApplicationLoader calls into NativeLoader.
2. app uses DexClassLoader, the classloader namespace is not created since the loading of this dex is not by ApplicationLoader. In this dex java code, app System.loadLibrary() and finally call into NativeLoader, and  namespace for new dex's classloader has not been created, so create classloader in OpenNativeLibrary().

For the first one, the path is library path of app. NativeBridge cannot determine whether the app needs it in app startup stage.
For the second one(we won't expect it here right?), the path is a library path, seems ok.

I think that, InitNamespaces is just like let NativeBridge turn into a mode such that it could well handle library loading. I suggest let namespace of NativeBridge always init. This only actually happens on Intel devices which really equipped with nativebridge implementation.

454:19-454:26
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bdc43ad3_a4ef628c
Bytes: 34
Is it NativeBridgeGetError() here?

477:5-477:23
Thu Jul 07 06:41:46 2016 +0000
Author: Zhenhua WANG <1104175@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bdc43ad3_849fc61d
Bytes: 113
NativeBridge v3 has NativeBridgeUnloadLibrary() now. NativeLoader can call it to unload a library when necessary.

