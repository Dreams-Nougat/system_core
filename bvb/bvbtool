#!/usr/bin/env python

# Copyright 2016, The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import Crypto.PublicKey.RSA
import hashlib
import os
import struct
import subprocess
import sys

# Keep in sync with bvb_boot_image_header.h
BVB_VERSION_MAJOR = 1
BVB_VERSION_MINOR = 0

def round_to_multiple(number, size):
    remainder = number%size
    if remainder == 0:
        return number
    return number + size - remainder

def read_uint64(f, offset):
    f.seek(offset)
    return struct.unpack('!Q', f.read(8))[0]


def write_uint32(f, offset, value):
    f.seek(offset)
    f.write(struct.pack('!L', value))


def write_uint64(f, offset, value):
    f.seek(offset)
    f.write(struct.pack('!Q', value))


def write_long(f, num_bits, value):
    for n in range(0, num_bits / 8):
        bit_pos = num_bits - 8 - n*8
        octet = (value >> bit_pos) & 0xff
        f.write(struct.pack('!B', octet))


def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y


def modinv(a, m):
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m


def parse_number(x):
    return int(x, 0)


def dump_public_key(f, key):
    # key.e is exponent
    # key.n is modulus
    key_num_bits = key.size() + 1
    # Calculate n0inv = -1/n[0] (mod 2^32)
    b = 2L**32
    n0inv = b - modinv(key.n, b)
    # Calculate rr = r^2 (mod N), where r = 2^(# of key bits)
    r = 2L ** key.n.bit_length()
    rrmodn = r*r % key.n
    f.write(struct.pack('!II',
                        key_num_bits,
                        n0inv))
    write_long(f, key_num_bits, key.n)
    write_long(f, key_num_bits, rrmodn)


ALGORITHMS = {
    'NONE': {
        'algorithm_type': 0,        # BVB_ALGORITHM_TYPE_NONE
        'hash_num_bytes': 0,
        'signature_num_bytes': 0,
        'public_key_num_bytes': 0,
        'padding' : []
    },
    'SHA256_RSA2048': {
        'algorithm_type': 1,        # BVB_ALGORITHM_TYPE_SHA256_RSA2048
        'hash_num_bytes': 32,
        'signature_num_bytes': 256,
        'public_key_num_bytes': 8 + 2*2048/8,
        'padding' : [
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*202 + [0x00] + [
            # ASN.1 header
            0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
            0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
            0x00, 0x04, 0x20,
        ]
    },
    'SHA256_RSA4096': {
        'algorithm_type': 2,        # BVB_ALGORITHM_TYPE_SHA256_RSA4096
        'hash_num_bytes': 32,
        'signature_num_bytes': 512,
        'public_key_num_bytes': 8 + 2*4096/8,
        'padding' : [
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*458 + [0x00] + [
            # ASN.1 header
            0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
            0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
            0x00, 0x04, 0x20,
        ]
    },
    'SHA256_RSA8192': {
        'algorithm_type': 3,        # BVB_ALGORITHM_TYPE_SHA256_RSA8192
        'hash_num_bytes': 32,
        'signature_num_bytes': 1024,
        'public_key_num_bytes': 8 + 2*8192/8,
        'padding' : [
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*970 + [0x00] + [
            # ASN.1 header
            0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
            0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
            0x00, 0x04, 0x20,
        ]
    },
    'SHA512_RSA2048': {
        'algorithm_type': 4,        # BVB_ALGORITHM_TYPE_SHA512_RSA2048
        'hash_num_bytes': 64,
        'signature_num_bytes': 256,
        'public_key_num_bytes': 8 + 2*2048/8,
        'padding' : [
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*170 + [0x00] + [
            # ASN.1 header
            0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
            0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
            0x00, 0x04, 0x40
        ]
    },
    'SHA512_RSA4096': {
        'algorithm_type': 5,        # BVB_ALGORITHM_TYPE_SHA512_RSA4096
        'hash_num_bytes': 64,
        'signature_num_bytes': 512,
        'public_key_num_bytes': 8 + 2*4096/8,
        'padding' : [
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*426 + [0x00] + [
            # ASN.1 header
            0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
            0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
            0x00, 0x04, 0x40
        ]
    },
    'SHA512_RSA8192': {
        'algorithm_type': 6,        # BVB_ALGORITHM_TYPE_SHA512_RSA8192
        'hash_num_bytes': 64,
        'signature_num_bytes': 1024,
        'public_key_num_bytes': 8 + 2*8192/8,
        'padding' : [
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*938 + [0x00] + [
            # ASN.1 header
            0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
            0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
            0x00, 0x04, 0x40
        ]
    },
}


def lookup_algorithm_by_type(alg_type):
    for alg_name in ALGORITHMS:
        alg_data = ALGORITHMS[alg_name]
        if alg_data['algorithm_type'] == alg_type:
            return (alg_name, alg_data)
    raise Exception('Unknown algorithm type %d' % alg_type)


def add_property(encoded_props, key, value):
    encoded_props.extend(struct.pack('!QQ', len(key), len(value)))
    encoded_props.extend(key)
    encoded_props.append(0)
    encoded_props.extend(value)
    encoded_props.append(0)
    num_bytes = 2*8 + len(key) + len(value) + 2
    padding_bytes = (8 - num_bytes) & 7
    for n in range(padding_bytes):
        encoded_props.append(0)


class BvbTool(object):
    def __init__(self):
        parser = argparse.ArgumentParser(
            usage='''bvbtool COMMAND [<args>]

Commands:
   version              Prints out version of bvbtool.
   make_boot_image      Make boot image.
   sign_boot_image      Sign boot image.
   info_boot_image      Show information about boot image.
   extract_public_key   Extract public key.

''')
        parser.add_argument('COMMAND', help='The command to run')
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.COMMAND):
            print 'Unrecognized command'
            parser.print_help()
            sys.exit(1)
        getattr(self, args.COMMAND)()


    def version(self):
        print '%d.%d' % (BVB_VERSION_MAJOR, BVB_VERSION_MINOR)


    def info_boot_image(self):
        parser = argparse.ArgumentParser(
            prog='bvbtool info_boot_image',
            description='Show information about Brillo boot image.')
        parser.add_argument('--image', help='Brillo boot image to sign',
                            type=argparse.FileType('rb'), required=True)
        parser.add_argument('--output', help='Write info to file',
                            type=argparse.FileType('wt'), default=sys.stdout)
        args = parser.parse_args(sys.argv[2:])

        (magic,
         version_major, version_minor,
         authentication_block_size,
         auxilary_block_size,
         payload_block_size,
         algorithm_type,
         hash_offset, hash_size,
         signature_offset, signature_size,
         public_key_offset, public_key_size,
         properties_offset, properties_size,
         rollback_index,
         kernel_offset, kernel_size,
         initrd_offset, initrd_size,
         device_tree_offset, device_tree_size,
         kernel_addr,
         initrd_addr,
         kernel_cmdline) = struct.unpack('!4s2L'   # magic, 2 x version
                                         '3Q'      # 3 x block size
                                         'L'       # algorithm type
                                         '2Q'      # offset, size (hash)
                                         '2Q'      # offset, size (signature)
                                         '2Q'      # offset, size (public key)
                                         '2Q'      # offset, size (properties)
                                         'Q'       # rollback_index
                                         '2Q'      # offset, size (kernel)
                                         '2Q'      # offset, size (initrd)
                                         '2Q'      # offset, size (device tree)
                                         'Q'       # kernel load address
                                         'Q'       # initrd load address
                                         '4096s',  # cmdline
                                         args.image.read(4272))
        # Nuke NUL-bytes at the end of the string.
        kernel_cmdline = kernel_cmdline.split('\0', 1)[0]

        (alg_name, _) = lookup_algorithm_by_type(algorithm_type)

        o = args.output
        o.write('Boot Image version:       %d.%d\n' % (version_major, version_minor))
        o.write('Header Block:             8192 bytes\n')
        o.write('Authentication Block:     %d bytes\n' % authentication_block_size)
        o.write('Auxilary Block:           %d bytes\n' % auxilary_block_size)
        o.write('Payload Block:            %d bytes\n' % payload_block_size)
        o.write('Algorithm:                %s\n' % alg_name)
        o.write('Rollback Index:           %d\n' % rollback_index)
        o.write('Kernel:                   %d bytes\n' % kernel_size)
        o.write('Initrd:                   %d bytes\n' % initrd_size)
        o.write('Device Tree:              %d bytes\n' % device_tree_size)
        o.write('Kernel Load Address:      0x%08x\n' % kernel_addr)
        o.write('Initrd Load Address:      0x%08x\n' % initrd_addr)
        o.write('Kernel Cmdline:           %s\n' % kernel_cmdline)

        # Print properties.
        o.write('Properties:\n')
        authentication_block_offset = 8192
        auxilary_block_offset = authentication_block_offset + authentication_block_size
        prop_start_offset = auxilary_block_offset + properties_offset
        prop_end_offset = prop_start_offset + properties_size
        args.image.seek(prop_start_offset)
        num_printed = 0
        while args.image.tell() < prop_end_offset:
            (key_len, value_len) = struct.unpack('!2Q', args.image.read(16))
            num_bytes = key_len + value_len + 2
            padding_bytes = (8 - num_bytes) & 7
            prop_data = args.image.read(num_bytes + padding_bytes)
            key = prop_data[0:key_len]
            # Avoid printing large property values (e.g. blobs).
            if value_len >= 256:
                o.write('    %s: (%d bytes)\n' %(key, value_len))
            else:
                value = prop_data[key_len + 1: key_len + 1 + value_len]
                o.write('    %s: %s\n' %(key, repr(value)))
            num_printed += 1
        if num_printed == 0:
            o.write('    (none)\n')

    def make_boot_image(self):
        parser = argparse.ArgumentParser(
            prog='bvbtool make_boot_image',
            description='Make Brillo boot image.')

        parser.add_argument('--kernel', help='Path to kernel',
                            type=argparse.FileType('rb')) #, required=True)
        parser.add_argument('--initrd', help='Path to ramdisk',
                            type=argparse.FileType('rb'))
        parser.add_argument('--device_tree', help='Path to device tree',
                            type=argparse.FileType('rb'))
        parser.add_argument('--kernel_address', help='Kernel load address',
                            type=parse_number, default=0x10008000)
        parser.add_argument('--initrd_address', help='Ramdisk load address',
                            type=parse_number, default=0x11000000)
        parser.add_argument('--kernel_cmdline', help='Kernel command-line',
                            default='')
        parser.add_argument('--rollback_index', help='Rollback Index',
                            type=parse_number, default=0)
        parser.add_argument('--prop', help='Add property',
                            metavar='KEY:VALUE', action='append')
        parser.add_argument('--prop_from_file', help='Add property from file',
                            metavar='KEY:PATH', action='append')
        parser.add_argument('--output', help='Output file name',
                            type=argparse.FileType('wb'),
                            required=True)
        args = parser.parse_args(sys.argv[2:])

        # Write header data block and leave ample room for hash, signature
        # and public key.
        authentication_data_block_size = 4096
        kernel_offset = 0
        kernel_size = os.fstat(args.kernel.fileno()).st_size
        initrd_offset = 0
        initrd_size = 0
        if args.initrd:
            initrd_offset = kernel_offset + kernel_size
            initrd_size = os.fstat(args.initrd.fileno()).st_size
        device_tree_offset = 0
        device_tree_size = 0
        if args.device_tree:
            device_tree_offset = initrd_offset + initrd_size
            device_tree_size = os.fstat(args.device_tree.fileno()).st_size
        payload_data_block_size = kernel_size + initrd_size + device_tree_size

        # Generate properties blob.
        prop_offset = 0
        prop_size = 0
        encoded_props = bytearray()
        if args.prop:
            for prop in args.prop:
                idx = prop.find(':')
                if idx == -1:
                    sys.stderr.write('Malformed --property value %s.\n', prop)
                    sys.exit(1)
                key = prop[0:idx]
                value = prop[(idx + 1):]
                add_property(encoded_props, key, value)
        if args.prop_from_file:
            for prop in args.prop_from_file:
                idx = prop.find(':')
                if idx == -1:
                    sys.stderr.write('Malformed --property value %s.\n', prop)
                    sys.exit(1)
                key = prop[0:idx]
                file_path = prop[(idx + 1):]
                value = open(file_path, 'rb').read()
                add_property(encoded_props, key, value)

        # We'll store the properties at offset 0 in the Auxiliary data
        # block. Make sure it's big enough to hold the biggest
        # possible key.
        auxilary_data_block_size = round_to_multiple(len(encoded_props) + 4096, 64)

        args.output.write(struct.pack('!4s2L'     # magic, 2 x version
                                        '3Q'      # 3 x block size
                                        'L'       # algorithm type
                                        '2Q'      # offset, size (hash)
                                        '2Q'      # offset, size (signature)
                                        '2Q'      # offset, size (public key)
                                        '2Q'      # offset, size (properties)
                                        'Q'       # rollback_index
                                        '2Q'      # offset, size (kernel)
                                        '2Q'      # offset, size (initrd)
                                        '2Q'      # offset, size (device tree)
                                        'Q'       # kernel load address
                                        'Q'       # initrd load address
                                        '4095sB', # cmdline, NUL
                                      'BVB0', BVB_VERSION_MAJOR, BVB_VERSION_MINOR,
                                      authentication_data_block_size,
                                      auxilary_data_block_size,
                                      payload_data_block_size,
                                      0,      # BVB_SIGNATURE_TYPE_NONE
                                      0, 0,   # hash offset, hash_size
                                      0, 0,   # signature offset, size
                                      0, 0,   # public_key offset, size
                                      0, len(encoded_props),
                                      args.rollback_index,
                                      kernel_offset, kernel_size,
                                      initrd_offset, initrd_size,
                                      device_tree_offset, device_tree_size,
                                      args.kernel_address,
                                      args.initrd_address,
                                      args.kernel_cmdline, 0))
        args.output.write(struct.pack('3920x'))
        assert args.output.tell() == 8192

        # Write Authentication data block, as zeroes.
        args.output.write(struct.pack(str(authentication_data_block_size) + 'x'))

        # Write Auxilary data block. First properties, then pad with zeroes.
        args.output.write(encoded_props)
        args.output.write(struct.pack(
            str(auxilary_data_block_size - len(encoded_props)) + 'x'))

        # Write Payload data block: kernel, initrd, and device tree
        args.output.write(args.kernel.read())
        if args.initrd:
            args.output.write(args.initrd.read())
        if args.device_tree:
            args.output.write(args.device_tree.read())


    def sign_boot_image(self):
        parser = argparse.ArgumentParser(
            prog='bvbtool sign_boot_image',
            description='Sign Brillo boot image.')
        group = parser.add_argument_group()
        group.add_argument('--show_algorithms', help='Show avaiable algorithms',
                           action='store_true')
        group = parser.add_argument_group()
        group.add_argument('--image', help='Brillo boot image to sign',
                           type=argparse.FileType('rab+'))
        group.add_argument('--key', help='Path to RSA private key file')
        group.add_argument('--algorithm', help='Algorithm to use')
        args = parser.parse_args(sys.argv[2:])

        if args.show_algorithms:
            algs = []
            for alg_name in ALGORITHMS:
                if alg_name != NONE:
                    algs.append(alg_name)
            algs.sort()
            for alg in algs:
                print alg
            sys.exit(0)

        # Support 'NONE' to avoid conditionals in build systems if
        # signing is not needed (this way they can always execute
        # 'bvbtool sign_boot_image --algorithm NONE')
        if args.algorithm == 'NONE':
            sys.exit(0)

        if not args.algorithm:
            sys.stderr.write('Option --algorithm is required.\n')
            sys.exit(1)
        if not args.image:
            sys.stderr.write('Option --image is required.\n')
            sys.exit(1)
        if not args.key:
            sys.stderr.write('Option --key is required.\n')
            sys.exit(1)

        try:
            alg = ALGORITHMS[args.algorithm]
        except:
            sys.stderr.write('Unknown algorithm %s.\n' % args.algorithm)
            sys.exit(1)

        # Check magic (TODO: more sanity checks).
        if args.image.read(4) != 'BVB0':
            sys.stderr.write('Given image does not look like a Brillo boot image.\n')
            sys.exit(1)

        header_data_block_size = 8192
        authentication_data_block_size = read_uint64(args.image, 12)
        auxilary_data_block_size = read_uint64(args.image, 20)
        payload_data_block_size = read_uint64(args.image, 28)
        properties_offset = read_uint64(args.image, 88)
        properties_size = read_uint64(args.image, 96)

        if properties_offset != 0:
            # This is just an implementation limitation which can be lifted later.
            sys.stderr.write('Only support images with props at the top.\n')
            sys.exit(1)

        if authentication_data_block_size < alg['hash_num_bytes'] + alg['signature_num_bytes']:
            sys.stderr.write('Insufficient room for storing hash and signature.\n')
            sys.exit(1)

        if auxilary_data_block_size < alg['public_key_num_bytes']:
            sys.stderr.write('Insufficient room for storing public key.\n')
            sys.exit(1)

        authentication_data_block_offset = 8192
        auxilary_data_block_offset = authentication_data_block_offset + authentication_data_block_size
        payload_data_block_offset = auxilary_data_block_offset + auxilary_data_block_size

        # Update header with hash type/offset/size, signature
        # type/offset/size, and public key size.
        write_uint32(args.image, 36, alg['algorithm_type'])
        # Hash offset and size (in Authentication data block).
        write_uint64(args.image, 40, 0)
        write_uint64(args.image, 48, alg['hash_num_bytes'])
        # Signature offset and size - it's stored right after the hash
        # (in Authentication data block).
        write_uint64(args.image, 56, alg['hash_num_bytes'])
        write_uint64(args.image, 64, alg['signature_num_bytes'])
        # Public key offset and size - follows properties (in Auxilary data block).
        write_uint64(args.image, 72, properties_size)
        write_uint64(args.image, 80, alg['public_key_num_bytes'])

        # Extract public key and insert it into "Public key data" block.
        key = Crypto.PublicKey.RSA.importKey(open(args.key).read())
        # Write the public key
        args.image.seek(auxilary_data_block_offset + properties_size)
        dump_public_key(args.image, key)

        # Calculate the hash.
        if args.algorithm[0:6] == 'SHA256':
            h = hashlib.sha256()
        elif args.algorithm[0:6] == 'SHA512':
            h = hashlib.sha512()
        else:
            sys.stderr.write('Unsupported algorithm.\n')
            sys.exit(1)
        args.image.seek(0)
        h.update(args.image.read(header_data_block_size))
        args.image.seek(auxilary_data_block_offset)
        h.update(args.image.read(auxilary_data_block_size))
        h.update(args.image.read(payload_data_block_size))
        # Write the hash
        args.image.seek(authentication_data_block_offset)
        binary_hash = h.digest()
        args.image.write(binary_hash)

        # Calculate the signature.
        p = subprocess.Popen(['openssl', 'rsautl', '-sign',
                              '-inkey', args.key, '-raw'],
                             stdin=subprocess.PIPE,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        padding_and_hash = str(bytearray(alg['padding'])) + binary_hash
        (pout, perr) = p.communicate(padding_and_hash)
        retcode = p.wait()
        if retcode != 0:
            sys.stderr.write('Error signing: %s\n' % perr)
            sys.exit(1)
        # Write the signature.
        args.image.seek(authentication_data_block_offset + alg['hash_num_bytes'])
        args.image.write(pout)


    def extract_public_key(self):
        parser = argparse.ArgumentParser(
            prog='bvbtool extract_public_key',
            description='Extract public key and dump it in the format used by Brillo.')
        parser.add_argument('--key', help='Path to RSA private key file',
                            required=True)
        parser.add_argument('--output', help='Output file name',
                            type=argparse.FileType('wb'),
                            required=True)
        args = parser.parse_args(sys.argv[2:])

        # Extract public key and insert it into "Public key data" block.
        key = Crypto.PublicKey.RSA.importKey(open(args.key).read())
        # Write the public key
        dump_public_key(args.output, key)


if __name__ == '__main__':
    BvbTool()
