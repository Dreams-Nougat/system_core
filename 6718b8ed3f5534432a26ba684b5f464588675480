Revision: 6718b8ed3f5534432a26ba684b5f464588675480
Patch-set: 2
File: include/nativebridge/native_bridge.h

26:43-26:44
Mon Aug 11 18:21:20 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6e5ebf4_67913d43
Bytes: 154
why do some APIs need a const std::string& while others take a const char * ? It's fine if this is the most convenient for callers, but it just seems odd.

26:43-26:44
Mon Aug 11 18:28:09 2014 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6e5ebf4_67913d43
UUID: 76ea93f0_d1ff04ca
Bytes: 261
Is this an API that will be used from other projects? Until stlport is out of the picture entirely, we need to be careful about using STL containers at API boundaries because the two STLs are not ABI compatible (we ran in to this problem while moving ART over).

26:43-26:44
Mon Aug 11 18:31:38 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76ea93f0_d1ff04ca
UUID: f6d0433d_55b88cc6
Bytes: 69
Yeah, that's a good point. We will be using this from other projects.

26:43-26:44
Mon Aug 11 21:31:44 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6d0433d_55b88cc6
UUID: 16d4f72c_590207dc
Bytes: 107
I thought frameworks and Art are moved over. On the Art side it's fine to switch to const char* if must be.

26:43-26:44
Mon Aug 11 21:35:20 2014 +0000
Author: Dan Albert <1043845@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16d4f72c_590207dc
UUID: 76ea93f0_7a05cde1
Bytes: 106
Are the frameworks off stlport now? I know I haven't done anything to move them away, but they might have.

26:43-26:44
Mon Aug 11 21:38:07 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76ea93f0_7a05cde1
UUID: 76c53378_9c9ac95c
Bytes: 104
Ups, my mistake, seems the jni stuff still happily needs stlport. So needs to be changed to const char*.

26:43-26:44
Mon Aug 11 23:25:27 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76c53378_9c9ac95c
UUID: 56ef4fff_d0493c9a
Bytes: 61
thanks Dan. I think it's better to just use const char* here.

File: nativebridge/native_bridge.cc

52
Mon Aug 11 18:21:20 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6e5ebf4_24a9f3fe
Bytes: 115
"cbs [IN] the pointer to NativeBridgeCallbacks"

art_cbs -> cbs, NativeBridgeArtCallbacks -> NativeBridgeCallbacks.

52
Mon Aug 11 21:31:44 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6e5ebf4_24a9f3fe
UUID: 16d4f72c_990f7f03
Bytes: 100
No. This was Art callbacks that the native bridge can use. I guess the name is now RuntimeCallbacks.

52
Mon Aug 11 23:25:27 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16d4f72c_990f7f03
UUID: 56ef4fff_f0444084
Bytes: 33
yep, need to be the runtime ones.

52
Tue Aug 12 08:26:34 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56ef4fff_f0444084
UUID: 56ef4fff_53b316d5
Bytes: 243
Hang on. My objection was to the fact that the struct is called NativeBridgeRuntimeCallbacks but the comment calls it NativeBridgeArtCallbacks. Given that, the formal parameter name "art_" is somewhat random. Call it either cbs or runtime_cbs.

54:46-55:54
Mon Aug 11 18:21:20 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56a3cfb2_a4725aaf
Bytes: 3
cbs

54:46-55:54
Mon Aug 11 23:25:27 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56a3cfb2_a4725aaf
UUID: 16d9576f_ce988329
Bytes: 4
Done

114:51-114:84
Mon Aug 11 15:44:53 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56a3cfb2_f9040b7e
Bytes: 145
I'm not sure what's the best strategy to pass this one. Thoughts?

Passing it together with the nb_library_string seems like a good option to me.

114:51-114:84
Mon Aug 11 16:33:45 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56a3cfb2_f9040b7e
UUID: d6133f9f_19ac578c
Bytes: 18
Makes sense to me.

114:51-114:84
Mon Aug 11 17:39:35 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6133f9f_19ac578c
UUID: 56a3cfb2_c4b75ed7
Bytes: 255
My only issue with this will related to pointer ownership, i.e. it seems easy to lose track of it when passing it through so many layers. I guess it can't be helped. 

Is there any reason why initialize doesn't take a const pointer? or it's just a glitch?

114:51-114:84
Mon Aug 11 21:31:44 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56a3cfb2_c4b75ed7
UUID: 76c53378_9ccc0970
Bytes: 209
I think a const * is fine, and it makes sense to have the caller retain ownership. Libnativebridge should not have to manage this, just pass it on. Then the caller can have this as a global (as it was in Art).

