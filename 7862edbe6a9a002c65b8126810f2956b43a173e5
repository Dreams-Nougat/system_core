Revision: 7862edbe6a9a002c65b8126810f2956b43a173e5
Patch-set: 1
File: adb/jdwp_service.cpp

500
Tue May 19 22:42:25 2015 +0000
Author: Stephen Hines <1010056@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: adfdb1c1_ceeab272
Bytes: 310
This is technically undefined behavior (writing to one part of a union and reading it as something else). Can you please memcpy() from a completed sockaddr_un to a sockaddr instead? The compiler can hopefully optimize away the actual call and replace it with the same loads/stores that happen in your case too.

500
Wed May 20 00:26:49 2015 +0000
Author: Bernhard Rosenkr√§nzer <1010121@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: adfdb1c1_ceeab272
UUID: ed19690f_bd95673d
Bytes: 387
Using a union is (or at least used to be) the recommended fix for this type of aliasing violation by the gcc guys (works in clang too), but it technically is undefined.

memcpy would work - another possibility would be adding __attribute__((may_alias)) to the sockaddr* definitions in Bionic, given sockaddr and friends usually come with casting pointers between different related types.

500
Wed May 20 00:38:48 2015 +0000
Author: Stephen Hines <1010056@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ed19690f_bd95673d
UUID: 2d37016d_a3a1b0ee
Bytes: 205
Our clang people say that unions should never be used this way going forward. Using a memcpy provides the proper aliasing information without resorting to attributes that people will neglect in the future.

