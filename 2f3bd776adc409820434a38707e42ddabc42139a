Revision: 2f3bd776adc409820434a38707e42ddabc42139a
Patch-set: 5
File: debuggerd/crash_dump.cpp

49
Wed Oct 26 18:06:06 2016 +0000
Author: Zach Riggle <1059554@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_2defd9d3
Bytes: 88
This can be spoofed via PID recycling.  You must use openat(), open()/fopen() is unsafe.

49
Wed Oct 26 18:15:14 2016 +0000
Author: Josh Gao <1079148@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_2defd9d3
UUID: c1d83cb2_0d9ad557
Bytes: 233
The idea was to fetch all of these values, and then check that the process hasn't died yet via getppid, but I like openat much better. ptrace is still vulnerable to this, so we still need to make sure that the process is still alive.

49
Wed Oct 26 18:45:53 2016 +0000
Author: Zach Riggle <1059554@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1d83cb2_0d9ad557
UUID: c1d83cb2_b00960a0
Bytes: 230
Yeah, it's probably an easier solution to pass around a file descriptor with /proc/XXX open.  I'm not sure how to avoid the race condition with ptrace, except to use openat() to get /proc/XXX and then check /status for "TracerPID"

78
Wed Oct 26 18:06:06 2016 +0000
Author: Zach Riggle <1059554@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_6de9d1cb
Bytes: 88
This can be spoofed via PID recycling.  You must use openat(), open()/fopen() is unsafe.

101
Wed Oct 26 18:06:06 2016 +0000
Author: Zach Riggle <1059554@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_4de68dfd
Bytes: 88
This can be spoofed via PID recycling.  You must use openat(), open()/fopen() is unsafe.

180:13-180:32
Wed Oct 26 03:12:56 2016 +0000
Author: Josh Gao <1079148@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1d83cb2_aa0f2f51
Bytes: 62
FIXME: this is presumably not the correct way of doing things.

