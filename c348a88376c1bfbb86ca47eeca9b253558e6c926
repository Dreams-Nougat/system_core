Revision: c348a88376c1bfbb86ca47eeca9b253558e6c926
Patch-set: 2
File: libcutils/arch-mips/android_memset.c

52
Thu Aug 27 21:37:49 2015 +0000
Author: Duane Sand <1010669@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 048f817d_638ad3f9
Bytes: 256
In the original sanitize object code for mips, I saw a conditional call to trap() when MSB of value was 1.
Meaning that uint16 was effectively just uint15.
That is likely a bug in mips clang or in sanitize definition.

I hope the above avoids that problem.

52
Thu Aug 27 22:49:30 2015 +0000
Author: Duane Sand <1010669@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 048f817d_638ad3f9
UUID: 248c8586_493b2287
Bytes: 495
Apparently 'uval16' in 'uval16<<16' promotes to signed integer before the shift is done, leading to questions about signed overflows!  Making an explicit promotion to unsigned integer before shifting, avoids the issue and retains the full 16-bit range when checking is on.

When sanity=integer is on,
   uval16 << 15
is handled okay with no checks,

   uval16 << 16
generates runtime code which traps if uval16 & 0x8000 is on,
and

   ((unsigned int)uval16) << 16
is handled okay with no checks.

52
Thu Aug 27 23:01:08 2015 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 248c8586_493b2287
UUID: e4750d3f_9273808e
Bytes: 659
"value" is 16 bits, and this was an attempt to shift a 16 bit value by 16 bits. This is undefined behavior. (C standard 6.5.7 item 1185 http://c0x.coding-guidelines.com/6.5.7.html).

The fact that this was working at all is somewhat amazing. This behavior has changed over time, and certain GCC optimizations rely on this undefined behavior ("shift-by-bitwidth" in http://blog.regehr.org/archives/1234).

Are you sure this code was ever working as expected? I bet you'll find that the old version of this code was broken... I bet nobody ever tested a non-zero memset value.  :-(

Your new code is the proper way it should have been written in the first place.

