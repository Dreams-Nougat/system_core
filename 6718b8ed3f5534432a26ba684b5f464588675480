Revision: 6718b8ed3f5534432a26ba684b5f464588675480
Patch-set: 2
File: include/nativebridge/native_bridge.h

26:43-26:44
Mon Aug 11 18:21:20 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6e5ebf4_67913d43
Bytes: 154
why do some APIs need a const std::string& while others take a const char * ? It's fine if this is the most convenient for callers, but it just seems odd.

File: nativebridge/native_bridge.cc

52
Mon Aug 11 18:21:20 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6e5ebf4_24a9f3fe
Bytes: 115
"cbs [IN] the pointer to NativeBridgeCallbacks"

art_cbs -> cbs, NativeBridgeArtCallbacks -> NativeBridgeCallbacks.

54:46-55:54
Mon Aug 11 18:21:20 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56a3cfb2_a4725aaf
Bytes: 3
cbs

114:51-114:84
Mon Aug 11 15:44:53 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56a3cfb2_f9040b7e
Bytes: 145
I'm not sure what's the best strategy to pass this one. Thoughts?

Passing it together with the nb_library_string seems like a good option to me.

114:51-114:84
Mon Aug 11 16:33:45 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56a3cfb2_f9040b7e
UUID: d6133f9f_19ac578c
Bytes: 18
Makes sense to me.

114:51-114:84
Mon Aug 11 17:39:35 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6133f9f_19ac578c
UUID: 56a3cfb2_c4b75ed7
Bytes: 255
My only issue with this will related to pointer ownership, i.e. it seems easy to lose track of it when passing it through so many layers. I guess it can't be helped. 

Is there any reason why initialize doesn't take a const pointer? or it's just a glitch?

