Revision: 87dcb805fd97325e4299519ae4063da89c4606d9
Patch-set: 3
File: libutils/SharedBuffer.cpp

52
Fri May 20 22:42:09 2016 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 37a21e12_021f3a49
Bytes: 247
This does not look safe. If this function is ever called by anyone who did not see 1 returned from SharedBuffer::release you have two race conditions. 1. two threads could free the same buffer. 2. free could be called without acquire memory order.

52
Fri May 20 23:47:46 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 37a21e12_021f3a49
UUID: 37a21e12_3dfb7b88
Bytes: 716
This seems to be intended solely as an (ineffective) error check.  It should probably abort rather than returning -1.

I think the only client is in VectorImpl.cpp.  It first checks  if (sb->release(SharedBuffer::eKeepStorage) == 1) .  It does not actually look at the error code we return here.

I think that leaving this as is is OK, since there doesn't seem to be an actual bug here.  I'll add a large deprecated warning at the beginning of the file to discourage new users.

I'm also OK with changing this to a void return and getting rid of the test.  Or possibly calling abort().

This is different from RefBase, since there seems to be agreement that this code should go away, or at least not get new clients.

123
Fri May 20 22:42:09 2016 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 37a21e12_6230bed8
Bytes: 235
What is the point having two ways to release the last reference? Why not:
prev = mRefs.fetch_sub(1, std::memory_order_release);
if (prev == 1) {
  atomic_thread_fence(std::memory_order_acquire);
  if ((flags & eKeepStorage) == 0) {
...

123
Fri May 20 23:47:46 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 37a21e12_6230bed8
UUID: 37a21e12_3d57fb48
Bytes: 461
This is presumably faster if most objects only ever acquire a single reference.  In the common case we then do just an acquire load, which (in the correct version) involves a single fence instead of two, and no load/store exclusive.

I was optimistically assuming the original owner had done this in whatever way was optimal.  Since the other solution didn't obviously dominate it, I decided to leave the original logic alone, modulo required correctness fixes.

